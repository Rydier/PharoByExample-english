% $Author$
% $Date$
% $Revision$
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6in,9in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
%Noury's commands
\newcommand{\nouryComment}[1]{\textcolor{red}{\textbf{\emph{#1}}}}

%=================================================================

\chapter{Sockets}\label{cha:sockets}
Modern softwares are often distributed on multiple devices and collaborate through a network in order to achieve some task.
The basic approach to set up such a collaboration is to use {\em sockets}.
A typical use is in the World Wide Web.
Browsers and servers do interact through HTTP sockets.

The concept of socket was first introduced by researchers from Berkley University in the \nouryComment{1960's}.
They defined the first socket API for the C programming language in the context of Unix operating systems.
Since then, the concept of socket was spread out to other operating systems.
It's API was ported to other programming languages including Smalltalk.

In this chapter, we present the socket's API in the context of Pharo Smalltalk.
We show through some examples how to to use sockets for building both clients and servers.

\section{Basic Concepts}
\subsection{Socket}
A remote communication involves at least two softwares exchanging some data bytes through a network.
Each software accesses the network through at least one socket (see figure~\ref{fig:socketConcept}).
A socket can then be defined as a {\em plug on a communication network}.

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{socketConcept.pdf}
	\caption{Softwares Remote Communication Through Sockets.}
	\label{fig:socketConcept}
\end{figure}

Sockets are used to achieve a bidirectional communication.
They allow both sending and receiving data.
Such interaction can be done according to some communication protocol which is encapsulated by the used sockets.
On the Internet and other networks such as ethernet LANs\footnote{Local Area Networks.}, two basic protocols widely used are {\em TCP/IP} and {\em UDP/IP}.

\subsection{TCP/IP vs UDP/IP}
TCP/IP stands for {\em Transmission Control Protocol / Internet Protocol} (TCP for short).
The use of TCP guarantees a reliable communication (no data loss).
It requires that softwares involves in the communication get connected before actually communicating. 
Once a connection is established interacting parties can send and receive an arbitrary amount of bytes.
This is often referred to as {\em stream communication}.
Data reach the destination in the same order of their sending.

UDP/IP stands for {\em User Datagram Protocol / Internet Protocol} (UDP for short).
Datagrams are chunks of data which size can not exceed 64KB.
UDP is an unreliable protocol because of two reasons.
First, UDP does not guarantee that  datagrams will actually reach there destination.
The second reason why UDP is qualified as unreliable is that the order of receptions of multiple datagrams from a single sender to some particular receiver may arrive in an arbitrary order.
However UDP is faster than TCP since no connection is required before sending data.
A typical use of UDP is  ``heart-beating'' as used in server-based social software, where clients need to notify the server their status (e.g. Requesting interactions, or Invisible).

\nouryComment{In a future version we will present UDP. But, so  far UDP does not work in \pharo.}
In the reminder of this chapter we will focus on TCP Sockets.
We first will present how to develop a simple client application using a socket
 
\section{Simple TCP Client}
We call {\em TCP client}  a software that initiates a TCP connection in order to exchange data with another software: the {\em server}.
It is important to mention that the client and the server may be developed in different languages.
The life-cycle of such a client in \pharo decomposes into 4 steps:
\begin{enumerate}
\item Create a TCP socket.
\item Connect the socket to some server.
\item Exchange data with the server through the socket.
\item Close the socket.
\end{enumerate}

\subsection{Create a TCP Socket}
\pharo provides a single socket class.
At creation, the socket type (TCP or UDP) is provided to the socket plugin of the virtual machine.
To create a TCP socket, you need to evaluate the following message 
\begin{center}
\ct!Socket newTCP!.
\end{center}
Method \ct!newTCP! hands out the tcp type (which is stored in the class variable \ct!TCPSocketType!) to set up a TCP socket.

\subsection{Connect a TCP Socket to some Server}
In order to connect a TCP Socket to some server, you need to have the object representing the IP address of the server.
This address is a instance of \ct!SocketAddress!.
A handy way to create it is to use \ct!NetNameResolver! that  provides IP style network name lookup and translation facilities.

\scrref{creatingSocketAddress} provides two examples of socket address creation.
The first one creates an address from a string from the server name (\ct!'www.esug.org'!), while the second does the creation from a string representing the server's IP address (\ct!'127.0.0.1'!).
Note that to use the \ct!NetNameResolver! you need a network connection.
The only exception is for retrieving the local host address.

\nouryComment{There are dedicated methods for retreiving the localhost address but they are buggy at the time of writing this text.}
\nouryComment{The NameLookupFailure exception is used ONLY in NetNameResolver class>>addressForName:timeout:. It should be more widely used.}

\begin{script}[creatingSocketAddress]{Creating a Socket Address}
| esugAddress localAddress |
esugAddress := NetNameResolver addressForName: 'www.esug.org'.
localAddress := NetNameResolver addressForName: '127.0.0.1'.
\end{script}

Now we can connect our TCP socket to our server as shown in \scrref{connectingTcpSocket}.
Message \ct!connectTo:port:! attempts to connect the socket to the server which address and port are provided as parameters.
\nouryComment{SocketAddress can also store the port of the server. 
However, NetNameResolver does NOT support building socket address WITH port.}
This message returns immediately after issuing to the system (through a primitive call) the request to connect the socket.
Message \ct!waitForConnectionFor: 10! suspends the current process until the socket is connected to the server.
It waits at most \ct!10! seconds as provided in the parameter.
If the socket is not connected after 10 seconds, the \ct!ConnectionTimedOut! exception is signaled. 
Otherwise, the execution can carry on by evaluating the expression \ct!clientSocket isConnected! which obviously answers \ct!true!.

\begin{script}[connectingTcpSocket]{Connecting a TCP Socket to some Server.}
| clientSocket serverAddress |
clientSocket := Socket newTCP.
serverAddress := NetNameResolver addressForName: 'www.esug.org'.
clientSocket 
	connectTo: serverAddress port: 80;
	waitForConnectionFor: 10.
clientSocket isConnected
\end{script}

\subsection{Exchange Data with Server}
Once connection is established, the client can send/receive data to/from the server.
By data we mean a \ct!ByteString!\footnote{One can send a \ct!ByteArray!, but the receiving socket will return a \ct!ByteString! however.}.
Typically, the client sends some request to the server and then expects receiving some response.
Web browsers act according to this schema.
A web browser is a client that issues a request to some web server identified by the URL.
Such request is often the path to some resource on the server such as an html file or a picture.
Then, the browser awaits the server response (e.g. html code, picture bytes).

\begin{script}[dataExhangeWithTcpSocket]{Exchanging Data with some Server through a TCP Socket.}
|clientSocket data|
... ``create and connect the TCP clientSocket''
clientSocket sendData: 'Hello server'.
data := clientSocket receiveData.
... ``Process data''
\end{script}

\scrref{dataExhangeWithTcpSocket} shows the protocol to send and receive data through a client socket.
Here, we send the string \ct-'Hello server!'- to the server using the the \ct!sendData:! message.
Next, we send the \ct!receiveData! to our client socket to make it wait for data reception.
Then, the content of variable \ct!data! is processed.

\begin{script}[dataReceptionTimeOut]{Bounding the Maximum Time for Data Reception.}
|clientSocket data|
... ``create and connect the TCP clientSocket''
[data := clientSocket receiveDataTimeout: 5.
... ``Process data''
] on: ConnectionTimedOut 
do: [:timeOutException|
	Transcript 
		cr;
		show: No data received!'; 
		space;
		show: 'Network connection is too slow or server is down.']
\end{script}

%Timeout
Note that by using  \ct!receiveData!, the client waits until the server either sends no more data, or close the connection.
This means that the client may wait indefinitely.
An alternative would be to have the client signal a \ct!ConnectionTimedOut! exception if it had waited too much as shown in \scrref{dataReceptionTimeOut}.
We use message \ct!receiveDataTimeout:! to ask the client socket to wait for 5 seconds.
If data is received during this period of time, it is processed silently.
But if no data is received during the 5 seconds, a \ct!ConnectionTimedOut! is signaled.
So, we log a description of what happened on the \ct!Transcript!.

\subsection{Close the Socket}
A socket remains alive while devices at both ends are connected.
Once the interaction is over, either the server or the client can decide to close the socket.
This can be done by sending the \ct!close! message to the socket.
The image where this message is evaluated will then send a close request to the other side.
The socket remains connected until the other side close it.
However, this may last indefinitely when there is an network failure or when the other side is down.
This is why sockets also answer the \ct!destroy! message, that frees system resources required by the socket.

In practice we do use \ct!closeAndDestroy!.
It first attempts to close the socket by sending the \ct!close! message.
Then, if the socket is still connected after a duration of 20 seconds, the socket is destroyed.
Note that there exist a variant \ct!closeAndDestroy: seconds! which gets as a parameter the duration to wait before destroying the socket.

\begin{script}[closeAndDestroy]{Closing a TCP Socket After Connection to a Web Site.}
| clientSocket serverAddress httpQuery htmlText |
Transcript cr; cr; show: 'Attempt to get a web page...'.
serverAddress := NetNameResolver addressForName: 'www.esug.org'.
clientSocket := Socket newTCP.
[clientSocket 
	connectTo: serverAddress port: 80;
	waitForConnectionFor: 10.
 httpQuery := 'GET / HTTP/1.1', String crlf, 
	'Host: www.esug.org:80', String crlf, 
	'Accept: text/html', String crlfcrlf.
 clientSocket sendData: httpQuery.
 htmlText  := clientSocket receiveDataTimeout: 5.
 Transcript cr; show: htmlText.
] ensure: [clientSocket closeAndDestroy].
Transcript cr; show: '...Done'
\end{script}

To summarize all steps described so far, we use the example of getting a web page from a server in \scrref{closeAndDestroy} .
First, we retrieve the IP address of the \url{www.esug.org} server.
Then, we create a TCP socket and connect it to the server.
We use the IP address we get in the previous step and the default port for web servers: 80.
Next we forge the HTTP\footnote{HyperText Transfer Protocol used for web communications.} query.
The string corresponding  to our query starts with the \ct!GET! keyword, followed by a slash saying that we would like to get the root file of the server.
Follows the protocol version \ct!HTTP/1.1!.
The second line recalls the host name and port.
The third and last line of the HTTP query refers to format accepted by our client. 
Since, we intend to display the result of our query on the \ct!Transcript!, we state that our client accepts texts with html format.
After sending the http query, we wait at most 5 seconds for the html text that we display on the \ct!Transcript!.
Socket connection, query sending and html reception are inside a block which execution is ensured to end with cleaning up socket related resources, by means of the \ct!closeAndDestroy! message.

\section{Simple TCP Server}
A {\em TCP Server} is a software that awaits TCP connections from TCP clients.
Once connection established, both the server and the client can send a receive data in any order.
A big difference between the server and the client is that the server uses at least two sockets.

\subsection{TCP Socket Server Life-cyle}
The life-cycle of a TCP server in \pharo  has 5 steps:
\begin{enumerate}
\item Create a first TCP socket, let's call it {\em socket$_1$}.
\item Wait for connections by making {\em socket$_1$}  listen on some port.
\item Accept a client request for connection. As a result,  {\em socket$_1$} will build a second socket, let's call it {\em socket$_2$}.
\item Exchange data with the client through {\em socket$_2$}. In the meanwhile, {\em socket$_1$} can continue to wait for connections, and possibly create new sockets to exchange data with other clients. 
\item Close {\em socket$_2$}.
\item Close {\em socket$_1$} when we decide to kill the server and stop accepting client connections.
\end{enumerate}

Concurrence is implicit in this life-cycle.
The server listens for incoming client's connection requests through {\em socket$_1$}, while exchanging data with some client through {\em socket$_2$}.
The server can even simultaneously exchange data with multiple clients through different sockets.
In the following, we describe a simple server class and explain the server's life-cycle and related concurrency issues.

\subsection{Simple Server Class}


\section{SocketStream}
\section{Network Interface Initialization?}
NetNameResolver class>>initializeNetwork
\section{A Basic Chat Application}
\section{Distributed Object Applications}
\section{Chapter summary}



%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%%%%%%%%%%%%Delete everything below

In this chapter, you will learn use  remote Smalltalk (\rst) in order to build a distributed system involving different Smalltalk images. 
Objects from some image can hold references on objects belonging to other images.
Thus, the collaboration among images is achieved by passing messages over the network.

\section{Remote Hello World}
\label{sec:helloWorld}
In this section we show the simplest example possible with \rst.
It involves two images A and B.
It consist in sending from image B the message \ct!show:! to the \ct!Transcript! of the image A.

We make the assumption that \rst is installed on both images\footnote{\rst can be obtained from \url{http://www.squeaksource.com/rST}.}.
On image A, we evaluate \scrref{helloWorldServerScript}.

\begin{script}[helloWorldServerScript]{Exporting the Transcript}
RSTBroker startOnPort: 7777.
RSTBroker export: Transcript named: 'myFirstExportedObject'.
\end{script}

We first run the \rst {\em broker} by evaluating the expression \ct!RSTBroker startOnPort: 7777!.
The broker is an object that manages remote object references.
It listens on a particular TCP/IP port (port number 7777 in this example) for reference requests incoming from remote images. 
In our example, we use the broker te {\em export} the local \ct!Transcript!.
That is we provide an identifier (\ct!'myFirstExportedObject'!) that allow forging remote references on the local \ct!Transcript!.

Now, we can evaluate the \scrref{helloWorldClientScript} on image B.
\begin{script}[helloWorldClientScript]{Exporting the Transcript}
|remoteTranscript|
RSTBroker startOnPort: 6666.
remoteTranscript := 'myFirstExportedObject@localhost:7777' asLocalObject.
remoteTranscript
	cr;
	show: 'Hello World'
\end{script}

We first run the \rst {\em broker} and make it listen port 6666\footnote{Port numbers can be the same if the images run on different devices}.
Then, we forge a reference on the remote transcript exported on image A.
Last, the obtained reference can be used like any Smalltalk reference.
It is stored in a variable (\ct!remoteTranscript!) and then used to send messages \ct!cr! and \ct!show:!.
%rST infrastructure takes care of transmitting the messages and their parameters over the network and then transmitting back the results.
Once our example is done, we need to shutdown the \rst infrastructure by evaluating \ct!RSTBroker stop! on each image.

\section{Steps fro Developing Distributed Systems}
Building a distributed system using \rst is achieved in six steps :
\begin{enumerate}
\item Build images with appropriate objects and their classes ;
\item Run each image on a different host ;
\item Start \rst broker on every image ;
\item Export at least one object in at least one image ;
\item Connect images by forging remote references on exported objects.
\end{enumerate}

Throughout this chapter, we'll use an example of a chat system to illustrate \rst concepts.
The chat system involves instances of two classes: \ct!Discussion! class and \ct!Chatter! class (class definitions~\ref{cls:DiscussionAndChatterClasses}).
Different remote chatters exchange string messages by means of a remote discussion object.
The discussion holds a reference on every chatter.
In return, each chatter holds a reference on the discussion object.
Besides, a chatter holds a name and a shared queue where are stored received messages.
Messages are always received through the discussion.
Each chatter sends messages to the discussion which is responsible of forwarding them to all other chatters.

\begin{classdef}[DiscussionAndChatterClasses]{Discussion and Chatter classes}
Object subclass: #Discussion
	instanceVariableNames: 'chatters'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Simple Chat'.

Object subclass: #Chatter
	instanceVariableNames: 'name receivedMessages discussion'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Simple Chat'
\end{classdef}


To build our chat system, we setup three images (step~1): image A with only the \ct!Discussion! class and two chatter images B and C with only the \ct!Chatter! class.
Then we run each image on a different host (step~2) and startup \rst brokers (step~3) on all three images.
We make the assumption that images A, B, and C run respectively on hosts {\sf 192.168.0.1}, {\sf 192.168.0.2}, and {\sf 192.168.0.3} .
We start \rst brokers for images A, B, and C on ports respectively number {\sf 6666}, {\sf 7777}, and {\sf 8888}.
Next, a discussion object is exported in image A (step~4) as following:

\begin{center}
\ct!RSTBroker export: Discussion new named: 'myDiscussion'!
\end{center}

Last, each chatter is created and connected to the discussion through a remote reference (step~5).
The \scrref{chatterCreationAndConnectionToDiscussion} shows how to perform this operation.
First variable \ct!remoteDiscussion! is setup with a reference on the remote discussion object.
This reference is obtained from a string composed of the identifier used for exporting the discussion (\ct!myDiscussion!), the IP address of the machine containing the discussion image (\ct!192.168.0.1!) and the port on which \rst broker of the discussion image is listing (\ct!6666!). 
Next, a new chatter named \ct!Mike! (i.e. its instance variable is set to \ct!Mike!) is created and assigned to the variable \ct!chatterMike!.
Last the connexion between the local chatter and the remote discussion is established by sending the message \ct!addChatter:! to \ct!remoteDiscussion!.
\Mthref{discussionAddChatter} shows the corresponding code.

\begin{script}[chatterCreationAndConnectionToDiscussion]{Chatter Creation and Connection to the Remote Discussion}
remoteDiscussion := 'myDiscussion@192.168.0.1:6666' asLocalObject.
chatterMike := Chatter named: 'Mike'.
remoteDiscussion  addChatter: chatter.
\end{script}

Note that the IP address can be replaced by the the device name provided that there is a DNS in the network.
For example, if the machine hosting the discussion is named \ct!myDevice.myDomain.com!, then the string to forge a remote reference on the discussion object is \ct!myDiscussion@myDevice.myDomain.com!.

\begin{method}[discussionAddChatter]{Establishing the connection between a discussion and chatters}
Discussion>>>addChatter: newChatter
	self chatters add: newChatter.
	newChatter discussion: self
\end{method}


\section{Remote Messages and Object Passing Modes}
%Introduit la notion de Proxy !!
A {\em remote message} is a message sent to an object belonging to a remote image.
Parameters and answers of remote message can be transmitted according to one of two modes: {\em by reference} or {\em by copy}.
Transmitting an object by reference means that the remote image receives a {\em proxy} of the actual object.
A proxy is a placeholder that forwards all received messages over the network to the original objects.
Transmitting an object by copy means that a copy of the object is created on the remote image.
Messages sent to the copy are processed locally to the remote image.
Note that transmitting an object by copy makes the assumption that the remote image contains the class of the copied object. 
It is the responsibility of the developer to assure the existence of such classes.

The decision to transmit a parameter either by reference or by copy is the responsibility of the parameter itself.
This decision is implemented in the \ct!remoteType! method.
Each class should inherit or implement this method to answer either \ct!#reference! or \ct!#copy! according to the desired transmission mode.

By default, an object is passed by reference, since the implementation of  \ct!remoteType! method in the \ct!Object! class answers \ct!#reference!.
This transmission mode is the most natural since the object remains unique in the whole distributed system likewise in a stand-alone \st image.
It is even mandatory for some objects that are bound to the virtual machine or some resource of the hosting device such as processes, sockets or files.

The transmission by copy is useful in cases where object duplication is more efficient since it avoids unnecessary network usage.
This is often the case for immutable objects such as small integers or characters.
The transmission by copy is even mandatory for some critical objects such as \ct!true! or \ct!nil!.
Last, transmission by copy can be necessary for software that deals with (desired or undesired) disconnections.
Each image can then continue working -- even off-line -- on its own object copies.
But, such feature requires an extra development effort to ensure that object copies remain in sync.

\section{Flexible Deployment}
Exporting objects requires that other images obtain somehow the identifier used for the export, and also the IP address  (or the name) and the port of the hosting device.
That is often fine when the distributed system involves only two images.
But, this approach does not scale well.
It becomes too heavy when multiple images export many objects.
In such situation, changing the hosting machine of an image, or at least its network settings including the port used by \rst broker may impact multiple images.
One needs to update them with the name or the address of the new host or with the new port number.
We refer to this situation as {\em rigid deployment}.
The opposite situation is {\em flexible deployment}, where images can be deployed on various networks with different machine IP settings while requiring no or little setup.

The simplest solution to achieve flexible deployment is to use a naming server.
The naming server is an image exporting a dictionary that is used by other images to export objects.
Exporting here means only storing an object under a key into the dictionary.
The key is often a string that is ``known'' by images that want to retrieve the exported object. 
Keys are set once for all on develop time.
On deployment, one only need to setup the IP address (or name) of the naming server and the port on which \rst is listening\footnote{We make the assumption here that all required code is already available on each image. A more flexible approach is illustrated by UbiquiTalk (\url{http://vst.ensm-douai.fr/UbiquiTalk}) where machines discover each other without the need of a naming server. Code is also installed on-demand. Developers only need to prepare a single image.}.

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{chatWithFlexibleDeployment.pdf}
	\caption{Chat application with a name server enabling flexible deployment.}
	\label{fig:chatWithFlexibleDeployment}
\end{figure}

To illustrate flexible deployment, let's evolve our chat application to allow having multiple discussions hosted by different machines.
We take an example involving five images as shown by figure~\ref{fig:chatWithFlexibleDeployment}.
Image~1, plays the role of a naming server.
It does require no code.
We simply evaluate on a workspace  \scrref{exportDictionaryForNameServer} which starts \rst broker and exports a dictionary.

\begin{script}[exportDictionaryForNameServer]{Setting up the naming server image}
RSTBroker startOnPort: 6666.
RSTBroker export: Dictionary new named: 'Registry'.
\end{script}

Image~2 hosts a discussion, say about squeak development.
Therefore, class \ct!Discussion! (introduced in~\ref{cls:DiscussionAndChatterClasses}) has to be installed on this image.
We create an instance of this class and register it in the naming server under the \ct!'squeak-dev'! name as shown by~\scrref{registerSqueakDevDiscussion}.
Basically, we retrieve the remote dictionary and store in it our discussion object in order to make it available for remote chatters.
Image~3 can be created similarly to host the \ct!'etoys'! discussion.

\begin{script}[registerSqueakDevDiscussion]{Registering the 'squeak-dev' discussion in the naming server}
| remoteRegistry |
RSTBroker startOnPort: 7777.
remoteRegistry := 'Registry@10.1.10.50:6666' asLocalObject.
remoteRegistry at: 'squeak-dev' put: Discussion new.
\end{script}

Now we can run chatters (i.e. images 4 and 5).
As shown by~\scrref{runChatterMike}, we only need to know the IP and port (respectively 10.1.10.50 and 6666) of the naming registry.
The registry allows us to view available remote objects and obtain a reference on the one we choose.
In this example, the remote registry we obtain a remote reference of the \ct!'squeak-dev'! discussion in order to make chatter Mike join it.
Note that now that the connexion is established, the naming registry is useless.
It can even be stopped without impacting the functioning of chats, since chatters hold direct references on the discussions.

\begin{script}[runChatterMike]{Connecting a chatter with a discussion using the naming server}
| chatterMike remoteRegistry squeakDevDiscussion |
chatterMike := Chatter named: 'Mike'.
RSTBroker startOnPort: 8888.
remoteRegistry := 'Registry@10.1.10.50:6666' asLocalObject.
squeakDevDiscussion := remoteRegistry at: 'squeak-dev'.
squeakDevDiscussion addChatter: chatterMike.
\end{script}


\section{Fault Detection and Management}
%\item Proxies + isReachable + RSTRemoteObjectUnreachable, RSTObjectNotFound
As compared with standalone software, distributed systems are more likely subject to faults caused by a device failure or a network disconnection.
Developers have then to handle such faults in order to allow the system continue to function even if part of it is down. 
In the context of our chat application example, a possible fault is the disconnection of a chatter.
Such disconnection may occur for a chatter using a wireless device that moves outside the radio range of a Wifi hotspot.

Disconnections and other faults can be detected in \rst either by sending the \ct!isReachable! message to the remote object, or by capturing exceptions \ct!RSTObjectNotFound! and \ct!RSTRemoteObjectUnreachable!.
The \ct!isReachable! message is answered \ct!true! if messages can be delivered to the receiver.
The \ct!RSTRemoteObjectUnreachable! exception is raised if the server hosting a remote object could not be found.
This is the case when the remote \rst broker is not started, or when the remote host is not connected to the network, or when it is simply off.
The \ct!RSTObjectNotFound! exception is raised when forging a remote reference using a wrong identifier.
For example, suppose that we have two images A and B running respectively  on hosts {\sf 192.168.0.1} and {\sf 192.168.0.2}.
We start  \rst brokers for images A and B, on ports respectively number {\sf 6666}, {\sf 7777}.
that a discussion was exported under the identifier \ct!'myDiscussion'! as showed in the following expression.
\begin{center}
\ct!RSTBroker export: Discussion new named: 'myDiscussion'!
\end{center}
The \ct!RSTObjectNotFound! will be raised if a chatter on image B mistypes the identifier when trying to get the proxy on the remote discussion with the code below.
\begin{center}
\ct!'discussion@192.168.0.1:6666' asLocalObject!
\end{center}
Note that the \ct!RSTObjectNotFound! exception may also mean that the remote discussion hasn't been exported.

Now let see how to use these facilities to build a reliable chatter for our chat application.
The reliable chatter should be able to switch off-line by buffering outgoing messages if it gets disconnected from the discussion.

\section{Remote exceptions and how they are handled}


\section{Remote References and Garbage Collection}



\section{Other stuff}
\begin{itemize}
\item snapshot of remote object inspector
\item Broker is singleton
\end{itemize}



%%%%%%%%%%%%%%%%%%%%% DELETE everything below
%Like all Smalltalk dialects, \sq is a reflective programming language.
%For a programming language, being reflective means that it allows both \emph{introspection} and \emph{intercession}.
%Introspection is the ability to \emph{look} at the data structures that define the language itself, like objects, classes, the execution stack.
%Intercession is the ability to \emph{modify} these structures, in other words to change the language semantics and the behavior of a program from within the program itself.
%For instance, this allows to add spy methods, or to manipulate the execution stack from a debugger.
%Note that while the Java language defines a ``reflective'' interface, it's not fully reflective, because it only provides a limited introspection.

%In this chapter, you will read about uses of introspection that are useful for day-to-day programming.

%
%\section{Under the hood: instances} % (fold)

%Using the inspector, you can look at an object, change the values of its instance variables, and even send messages to it. Execute the following code in a workspace:
%\begin{script}[inspectobject]{Inspecting an object}
%| w |
%w := Workspace new.
%w openLabel: 'myworkspace'.
%w inspect
%\end{script}

%This will open another workspace and an inspector.
%The inspector shows the internal state of this new workspace, listing its instance variables in the left part (\ct!dependents!, \ct!contents!, \ct!bindings!...) and the value of the selected instance variable in the right part.
%The \ct!contents! instance variable represents whatever the workspace is displaying in its text area, so i you select it, the right part will show an empty string.
%Now type \ct!'1+2'! in place of that empty string, then \emph{accept} it.
%The value of the \ct!contents! variable changed, but the workspace window didn't notice it, so it didn't redisplay itself.
%To trigger the window refresh, evaluate \ct!self contentsChanged! in the lower part of the inspector. \damien{the french version says that the refresh didn't happen because \ct!contents:! doesn't trigger it, but the inspector bypasses the accessor...}

%How does the inspector work?
%In Smalltalk, all instance variables are protected.
%In theory, it is thus impossible to access them if the class doesn't define any accessor.
%In practice, the inspector does access instance variables without needing accessors, because it uses the reflective abilities of \st.
%In \st, classes define instance variables either by name or by numeric indexes.
%The inspector uses methods defined by the \ct!Object! class to access them: \ct!instVarAt: index! and \ct!instVarNamed: aString! to get the value of the instance variable at position \ct!index! or identified by \ct!aString!, respectively; to assign new values to these instance variables, it uses \ct!instVarAt:put:! and \ct!instVarNamed:put:!.
%For instance, you can change the value of the \ct!w! instance variable of the workspace with: \ct!w instVarNamed: 'contents' put: '3+4'; contentsChanged!.

%Please note that these methods are useful to build development or debugging tools, but using them to develop usual applications is a bad idea: these reflective methods break the encapsulation principles of object-oriented programming.

%Both methods \ct!instVarAt:! and \ct!instVarAt:put:! are primitive methods, meaning that they invoke a primitive operation of the \sq virtual machine.
%If you consult the code of these methods, you will see this invocation uses the strange syntax \ct!<primitive: xx>! where \ct!xx! is an integer.
%There is a limited number of primitive operations ---primitives for short--- and they constitute the basic actions in \sq: basic operations on integers, accessing input/output peripherals (disk, screen, network...).
%Some of these primitives also accelerate system functions.
%It is also possible to define custom primitives and to link them to plugins written in C to benefit from external libraries or from the speed of a native implementation.

%Here is the code of the method \ct!instVarAt:! defined by \ct!Object!:
%\begin{method}[instVarAt]{Exemple of primitive method}
%Object>>>instVarAt: index
%  "Primitive. Answer a fixed variable in an object. The numbering of variables corresponds to the named instance variables. Fail if the index is not an Integer or is not the index of a fixed variable. Essential. See Object documentation whatIsAPrimitive."
%  <primitive: 73>
%  "Access beyond fixed variables."
%  ^self basicAt: index - self class instSize
%\end{method}

%Typically, the code after the primitive invocation is not executed.
%It is executed only when the primitive fails, \eg in this case if we try to access a variable that does not exist.
%This enables to trigger the debugger on primitive methods; it is possible to modify the code of primitive methods, but beware, this is a quite risky business for the stability of your \sq system.

%The following script shows how to display in a \ct!Transcript! window (menu \menu{open ... Transcript}) the contents of the instance variables of a random instance of class \ct!SystemWindow!.
%The method \ct!allInstVarNames! returns all the names of the instance variables of a given class.
%The method \ct!someInstance! returns the first instance of a class it finds in the memory.

%\begin{figure}[ht]\centering
%	\includegraphics[width=.75\linewidth]{allInstanceVariables}
%	\caption{Displaying all instance variables of a random instance of \ct!SystemWindow!.\label{fig:allInstanceVariables}}
%\end{figure}

%In the same spirit, it is possible to gather instances that have specific properties.
%For instance, to get all instances of class \ct!Browser! whose instance variable \ct!systemOrganizer! is not \ct!nil!, try this expression: \ct!Browser allInstances select: [:c | (c instVarNamed: 'systemOrganizer') notNil]!.

%Now let's look at how the method \ct!instanceVariableValues! of \ct!Object! is defined \mthref{instanceVariableValues}. This method returns an array of all values of instance variables defined by this class, excluding the inherited instance variables.
%For instance, \ct!(1@2) instanceVariableValues! returns an \ct!OrderedCollection! containing \ct!1! and \ct!2!.
%This example shows how useful it is to be able to access instance variables via their position.
%The method \ct!instSize! returns the number of instance variables that a class defines.

%\begin{method}[instanceVariableValues]{Getting the values of all instance variables}
%Object>>>instanceVariableValues
%	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class."
%	
%	| c |
%	c := OrderedCollection new.
%	self class superclass instSize + 1
%		to: self class instSize
%		do: [ :i | c add: (self instVarAt: i)].
%	^ c
%\end{method}

%This method iterates over the indexes of instance variables that the class defines, starting just after the last index used by the superclasses.

%The development tools in \sq (code browser, debugger, inspector...) all use these reflective features.
%Here are a few other methods that might be useful to build development tools:
%\begin{itemize}
%	\item \ct|isKindOf: aClass| returns true if the receiver is instance of the given class or of one of its superclasses.
%	For instance, \ct!1.5 isKindOf: Number! returns \ct!true!, whereas \ct!1.5 isKindOf: Integer! is \ct!false!.
%	\item \ct!respondsTo: aSymbol! returns true if the receiver has a method whose selector is \ct!aSymbol!.
%	For instance, \ct!1.5 respondsTo: #floor! returns \ct!true!, because class \ct!Number! implements method \ct!floor! that rounds a number.
%	Similarly, \ct!Exception respondsTo: #,! because it is possible to group exceptions into a set by sending them the \ct!#,! message.
%\end{itemize}

%Once again, the reflective features of \sq are only useful to define development tools, and it is risky to use them to develop applications.
%Indeed, using the type of an object to drive execution of a method or another often reveals a design problem.
%\st offers other introspection possibilities for methods or the execution stack, the process scheduler, the memory manager... but we can't detail everything here; try to read the code and experiment by yourselves.

%% section under_the_hood_instances (end)

%
%\section{Browsing the code} % (fold)

%In \st, classes are normal objects, and they provide interesting features to navigate live objects.
%As we saw previously, you can obtain an instance of a given class by sending it the \ct!#someInstance! message.
%You can also gather all the instances with \ct!#allInstances!, or the number of alive instances in memory with \ct!#instanceCount!.
%These features are really useful when debugging an application, because you can ask a class to enumerate its methods that have specific properties:
%\begin{itemize}
%	\item \ct!Point whichSelectorsAccess: 'x'! returns the list of all methods that read the value of instance variable \ct!x! of class \ct!Point! as a set of selectors: \ct!an IdentitySet(#rotateBy:about: #translateBy: #isInsideCircle:with:with: #sideOf: #nearestPointAlongLineFrom:to: #normalized #eightNeighbors #dist: #hash #rotateBy:centerAt: #theta #grid: #fourNeighbors #dotProduct: #scaleFrom:to: #normal #onLineFrom:to:within: #+ #degrees #interpolateTo:at:)!.
%	\item \ct!Point whichSelectorsStoreInto: 'x'! returns the selectors of methods that modify the value of instance variable \ct!x!.
%	\item \ct!Point whichSelectorsReferTo: #+! returns the selectors of methods that send message \ct!#+!.
%	\item \ct!Point crossReference! associates each method with the set of messages it sends.
%	\item \ct!Rectangle whichClassIncludesSelector: #inspect! returns the superclass of \ct!Rectangle! that implements the \ct!inspect! method, in this case, \ct!Object!.
%	\item \ct!Rectangle unreferencedInstanceVariables! returns the list of instance variables that are not used either in the class or in its subclasses; for \ct!Rectangle! there are no unused instance variables.
%\end{itemize}

%If you need to navigate the classes in a \sq image, look at the \ct!SystemNavigation! class:
%\begin{itemize}
%	\item \ct!SystemNavigation default! returns the instance you can use to navigate the system.
%	\item \ct!SystemNavigation default allClassesImplementing: #+! returns all classes that implement the message \ct!#+!.
%	In this case we get \ct!an Array(Number Fraction Float Integer SmallInteger LargePositiveInteger ScaledDecimal DateAndTime Duration Timespan Player Color Collection WordArray FloatArray KedamaFloatArray String Interval AbstractSound MixedSound Point Voice Complex TraitDescription TraitComposition TraitTransformation TComposingDescription)!.
%	As you can see, it is possible to add integers, fractions, strings or intervals.
%	\item \ct!SystemNavigation default allSentMessages! returns all messages sent in the \sq image (more than 26000 in our image).
%	\item \ct!SystemNavigation default allUnsentMessages! returns all messages (more than 6000...) that have methods implementing them, but are never sent explicitly in the image. These messages are not necessarily useless, because they can be sent implicitely.
%	\item \ct!SystemNavigation default allUnimplementedCalls! returns all messages sent but not implemented.
%	This is more problematic because they often reveal features that are not implemented in the image.
%	\item \ct!SystemNavigation default allCallsOn: #Point! returns all messages sent explicitly to \ct!Point! as a receiver.
%\end{itemize}

%All these features are integrated in the programming environment of \sq, in particular in the code browsers.
%As shown in \secref{cha:env}, you can list all methods that have the same name (implementors) or all methods that send a message (senders).
%This is quite handy: for instance, when you want to change the name of a method, to check that you didn't miss one message send that could invoke this method (\figref{implementors}). \damien{is "invoke a method" OK here?}

%\begin{figure}[ht]\centering
%	\includegraphics[width=.75\linewidth]{implementors}
%	\caption{Displaying all classes that implement \ct!\#+!.\label{fig:implementors}}
%\end{figure}

%To see the internal structure of a class, you can inspect it like any object.
%In \figref{CompiledMethod}, the inspector at the back shows the structure of class \ct!Point!.
%You can see that the class stores its methods in a dictionary, indexing them by their selector.
%The frontmost inspector shows the decompiled bytecode of \ct!Point!'s method \ct!#*!.

%\begin{figure}[ht]\centering
%	\includegraphics[width=.75\linewidth]{CompiledMethod}
%	\caption{Inspecting class \ct!Point! and the bytecode of its \ct!\#*! method.\label{fig:CompiledMethod}}
%\end{figure}

%\st is really a completely open and transparent system, where all the code is available for reading.
%You can study the whole system as you wish, because there is no hidden code.
%The primitive part of the system, \ie which is not written in \st, is reduced to its simplest expression.
%Among \st dialects, \sq has the peculiarity that even its virtual machine is written in \st, so it is possible to run and debug it inside a \sq image!
%Though this actually works, it is quite slow, and for actual use the virtual machine is translated to C and compiled to a native executable.

%% section browsing_the_code (end)

%
%\section{Practical uses for introspection} % (fold)

%\subsection{Code metrics}

%Let's see how we can use \st's introspection features to quickly define code metrics.
%A code metric is a measure of program code like depth in the inheritance hierarchy, the number of direct or indeirect subclasses, the number of methods or of instance variables in each class, or the number of locally defined methods or instance variables.
%When discovering the code of a new application, you can evaluate a metric to get a rough idea of what the code looks like.
%\scrref{metrics} computes a few code metrics for Morphic; these numbers can vary depending on the image you are using.
%Results for class \ct!Morph!, which is the superclass of all graphical objects in \sq, reveal that it is a huge class, and that it is at the root of a huge hierarchy. Maybe it needs some refactoring!

%\begin{script}[metrics]{A few code metrics}
%	inheritanceDepth := Morph allSuperclasses size. "2"
%	methods := Morph allSelectors size. "1593"
%	instVars := Morph allInstVarNames size. "6"
%	addedMethods := Morph selectors size. "1165"
%	addedInstVars := Morph instVarNames size. "6"
%	directSubclasses := Morph subclasses size. "45"
%	totalSubclasses := Morph allSubclasses size. "412"
%\end{script}

%One of the most interesting metrics in the domain of object-oriented languages is the number of methods that extend methods inherited from the superclass.
%This informs us about the relation between the class and its superclasses.

%Here is a script that identifies methods in class \ct!Browser! that call the method they redefine, like this:
%\begin{code}{}
%Browser >>> xx
%	"..."
%	super xx
%\end{code}

%\begin{script}[browsersendstosuper]{Methods of \ct!Browser! redefining via \ct!super!}
%Browser selectors select: [ :eachSelector |
%	| method |
%	method := Browser compiledMethodAt: eachSelector.
%	method sendsToSuper ]
%\end{script}

%In this code, we ask to class \ct!Browser! all messages it understands (\ct!selectors!) then select those whose associated method makes a call to the superclass.
%This returns a collection of methods, containing for instance \ct!#veryDeepInner!.
%You can see that the \st bytecode itself is viewed as an object that we can query for information.
%We could even imagine methods that transform this bytecode.

%
%\subsection{Detecting possible errors}

%Sending a message to \ct!super! is a bad idea when that message is different from the one the current method implements.
%This practice often causes bugs when adding subclasses, so good developers avoids that pattern of code.
%It's easy to automatically identify occurences of this pattern: we simply have to find methods that make super-sends with a different selector than their own.

%\begin{script}[findSuperSends]{Identifying bad super-sends}
%Collection selectors select: [ :eachSelector |
%	| method |
%	method := Collection compiledMethodAt: eachSelector.
%	method sendsToSuper and: [(method messages includes: eachSelector) not]]
%\end{script}

%Note that this script doesn't find everything we want... it doesn't detect methods containing loops or recursion like the following:
%\begin{code}{}
%xxx
%	super yyy. "send something else than xxx to super"
%	self zzz
%\end{code}

%When executing \scrref{findSuperSends} on class \ct!Collection!, you should obtain method \ct!printNameOn:! which does send \ct!printOn:! to \super:
%\begin{method}[printNameOn]{A method that sends a different message to super}
%Collection>>>printNameOn: aStream
%	super printOn: aStream
%\end{method}

%In fact this method is used by \ct!printOn:! (\mthref{oldPrintOn}), which could be refactored as in \mthref{newPrintOn}.

%\begin{method}[oldPrintOn]{The sender of \lct{\#printNameOn:}}
%Collection>>>printOn: aStream
%	"Append a sequence of characters that identify the receiver to aStream."
%	self printNameOn: aStream.
%	self printElementsOn: aStream
%\end{method}

%\begin{method}[newPrintOn]{New version of \mthref{oldPrintOn}, after inlining the \lct{\#printNameOn:} super-send}
%Collection>>>printOn: aStream
%	"Append a sequence of characters that identify the receiver to aStream."
%	super printOn: aStream.
%	self printElementsOn: aStream
%\end{method}

%Now \ct!#printNameOn:! (\mthref{printNameOn}) is not needed anymore. Well, in this case... is it used in other classes? Let's ask \sq:
%\begin{example}[sendersofprintnameon]{Asking for the senders of \lct{\#printNameOn:}}{}
%SystemNavigator default allCallsOn: #printNameOn:
%--> an OrderedCollection(A MethodReference RunArray >> printOn: aMethodReference Bitmap >> printOn: aMethodReference Text >> printOn: aMethodReference CompiledMethod >> printOn:)
%\end{example}

%So we should also refactor classes \clsind{RunArray}, \clsind{BitMap}, \clsind{Text}, and \clsind{CompiledMethod} that are sending message \ct!#printNameOn:!.

%
%\subsection{Intelligent breakpoints}

%In the 3.8 version of \sq introduced a new kind of breakpoints.
%Those are quite useful and are implemented by the \ct!Object>>>haltIf:! method.
%This breakpoint only halts program execution if the method it's placed in was called by the one whose name was passed as an argument.
%This is very useful to halt a method only during the execution of a test and not every time it is called.
%For instance, the expression \ct!self haltIf: #testFoo! will only halt execution of its containing method if this method was called, directly or indirectly, from \ct!testFoo!.
%The definition of \ct!haltIf:! is quite simple and fits in five lines; it uses the pseudo-variable \ct!thisContext!, which refers to the execution stack, represented as an object (\ct!thisContext! is one of the six keywords in Smalltalk, with \self, \super, \nil, \ct!true!, and \ct!false!).

%\begin{method}[objecthaltif]{Implementation of a conditional breakpoint}
%Object>>>haltIf: condition
%	"This is the typical message to use for inserting breakpoints during debugging. Param can be a block or expression, halt if true.
%	If the condition is a selector, we look up in the callchain. Halt if any method's selector equals selector."
%	| cntxt |
%	cntxt := thisContext.
%	[cntxt sender isNil] whileFalse: [
%		cntxt := cntxt sender.
%		(cntxt selector = condition) ifTrue: [Halt signal]].
%	^self.
%\end{method}

%Starting from \ct!thisContext!, \ct!haltIf:! goes up through the execution stack, checking if the name of the calling method is the same as the one passed as parameter.
%If this is the case, then it raises an exception which, by default, summons the debugger.
%This example shows the power of Smalltalk, which allows to define powerful features and tools from within the language itself.

%The pseudo-variable \ct!thisContext! is especially used in the \sq debugger.
%It contains an instance of the \clsind{MethodContext} class.
%This instance contains information about the method that is being executed, the stack pointer (\ct!stackpc!), and the program pointer (\ct!pc!).

%In the following example, we halted \sq's evaluation loop by pressing \short{.} and inspecting the current context.

%\begin{figure}[ht]\centering
%	\includegraphics[width=\linewidth]{MethodContext}
%	\caption{Inspecting the execution context of the evaluation loop in \sq.\label{fig:MethodContext}}
%\end{figure}

%Via \ct!thisContext!, the Seaside web framework also accesses the execution stack, but it modifies it on the fly to easily implement reusable components over HTTP.

%% section practical_uses_for_introspection (end)


