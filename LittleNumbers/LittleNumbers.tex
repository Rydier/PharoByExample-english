% $Author: ducasse $
% $Date: 2009-08-24 10:17:33 +0200 (Mon, 24 Aug 2009) $
% $Revision: 28563 $

% HISTORY:


%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================

\chapter{Little Numbers}

We manipulate numbers all the time and in this Chapter we propose you a little journey into the way 
integers are mapped to their binary representations. We will start with some simple reminders on math that are the basics of our digital world. Then we will have a look at how integers and in particular small integers are encoded.

\section{Power of 2}

Let's start with some simple maths. 


\begin{code}{}
2 raisedTo: 0
	returns 1

2 raisedTo: 2
	returns 4
	
2 raisedTo: 8
	returns 256
\end{code}

Figure~\ref{power} shows the power of 2. 
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.65\textwidth]{16bits-number}
\caption{Power of 2 and their numerical equivalence.\label{power}}
\end{center}
\end{figure}

How to encode 13? It cannot be higher than $2^{4}$ because $2^{4}$ = 16. So it should be 8 + 4 + 1, $2^{3} + 2^{2} + 2^{0}$.

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.65\textwidth]{16bits-number13}
\caption{13 = $2^{3} + 2^{2} + 2^{0}$.}
\end{center}
\end{figure}


\begin{code}{}
(2 raisedTo: 0)
	returns 1

2 raisedTo: 2
	returns 4
	
2 raisedTo: 8
	returns 256
\end{code}

\subsection*{Binary notation}
Smalltalk has a format for representing number in different basis

\begin{code}{}
2r01101
	returns 13

13 printStringBase: 2
	returns '01101'
	
Integer readFrom: '01101' base: 2 	
	returns 13
\end{code}



\section{Bit shifting is multiplying by 2}

Integers are represented as sequences of bits. Therefore it is possible to shift all the bits from a given amount to obtain another integers. Shifting bit is equivalent to perform a multiplication by two. Figure~\ref{bitshiftmult} illustrates this point. Smalltalk offers three messages to shift bits: \ct{>> aPositiveInteger}, \ct{<< aPositiveInteger} and \ct{bitShift: anInteger}. The following examples show how to use them.


\begin{code}{Using \ct{>>} and \ct{<<}}
2r000001000 
	returns 8

2r000001000 >> 1
	returns 4
	
2r000001000 << 1
	returns 16
\end{code}

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.65\textwidth]{16bits-numberMultiplication}
\caption{Multiply by 2 or dividing by 2.\label{bitshiftmult}}
\end{center}
\end{figure}

\begin{code}{Using \ct{bitShift:}}
2r000001000 
	returns 8

2r000001000 bitShift: -1
	returns 4
	
2r000001000 bitShift: 1
	returns 16
\end{code}

The previous examples show only bit shifting for number with a single 1 bit but there is no constraint at this level.
The complete sequence of bits can be shifted as shown with \ct{2r000001100} below.


\begin{code}{}
2r000001100 
	returns 12

2r000001100 bitShift: -1
	returns 2r00000110
	returns 6 
	
2r000001100 bitShift: 1
	returns 2r000011000
	returns 24
\end{code}

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.65\textwidth]{16bits-numberMultiplication2}
\caption{Mutiply by 2 or dividing by 2. We can move several bits in one direction.}
\end{center}
\end{figure}

\subsection*{Shifting bits}


\begin{code}{}
2 raisedTo: 8
	returns 256
	
1 << 8
	returns 256
	
2r100000000
	returns 256
		
\end{code}

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.65\textwidth]{16bits-1shifted8}
\caption{We move 8 times 1 to the left. So from $2^{0}$ we get $2^{8}$.}
\end{center}
\end{figure}

\begin{code}{}
(2 raisedTo: 8) + (2 raisedTo: 10) 
	returns 1280
	
2r010100000000
	returns 1280
	
2r010100000000 >> 8
	returns	2r0101
	returns 5
\end{code}

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.65\textwidth]{16bits-1280shifted8}
\caption{We move 8 times to the right. So from 1280 gets 5.}
\end{center}
\end{figure}







\section{Bit Access}

\begin{code}{}
2r000001101 bitAt: 0
	returns 0 
	
2r000001101 bitAt: 1
	returns 1 
	
2r000001101 bitAt: 2
	returns 0 
			
2r000001101 bitAt: 3
	returns 1
	 
2r000001101 bitAt: 5
	returns 0 	 
\end{code}


\begin{code}{}
Integer>>bitAt: anInteger
	"Answer 1 if the bit at position anInteger is set to 1, 0 otherwise.
	self is considered an infinite sequence of bits, so anInteger can be any strictly positive integer.
	Bit at position 1 is the least significant bit.
	Negative numbers are in two-complements.
	
	This is a naive implementation that can be refined in subclass for speed"
	
	^(self bitShift: 1 - anInteger) bitAnd: 1
\end{code}

We shift to the right from an integer minus one (hence \ct{1 - anInteger})
and with a \ct{bitAnd:} we know whether there is a one or zero in the location.

%

\section{More here}




\subsection{Ten's complement of a number}

To fully understand 2's complement it is interesting to see how it works with decimal numbers. There is no obvious usage for 10's complement but here the point we want to show is that a complement is the replacement of addition with subtraction (\ie adding the complement of A to B is equivalent to subtracting A from B).


The 10's complement of a positive decimal integer \ct{n} is 10 to the power of k, minus n, where k is the number of digits in the decimal representation of \ct{n}. It can be calculated in the following way: 

\begin{enumerate}
\item replace each digit \ct{d} of the number by \ct{9-d} and  
\item add one to the resulting number.
\end{enumerate}

This two steps rule is equivalent to the following one which looks more complex. Computer scientists will probably prefer the first way since it is more regular and adding 1 is cheaper than making more tests.

\begin{enumerate}
\item All the zeros at the right-hand end of the number remain as zeros. 
\item The rightmost non-zero digit \ct{d} of the number is replaced by \ct{10 - d}. 
\item Each other digit \ct{d} is replaced by \ct{9 - d}. 
\end{enumerate}

\paragraph{Examples.}
The 10's complement of \ct{1968} is \ct{9-1}, \ct{9-9}, \ct{9-6}, \ct{9-8} + 1 \ie \ct{8031 + 1} \ie \ct{8032}. 
Using the rule two we compute \ct{9-1}, \ct{9-9}, \ct{9-6}, \ct{10-8} \ie \ct{8032}. So our 10's complement is \ct{8032}. Indeed \ct{1968 + 8032 = 10000 =} $10^{5}$. Therefore it follows well the definition above: \ct{8032} is the result of \ct{10000 - 1968}.

The 10's complement of \ct{190680} is then \ct{9-1}, \ct{9-9}, \ct{9-0}, \ct{9-6}, \ct{9-8}, \ct{9-0} + 1 \ie \ct{809319 + 1} \ie \ct{809320}. Let's verify: \ct{190680 + 809320 = 1000000}.
 
So to compute the 10's complement of a number, it is enough to perform \ct{9-d} for each digit and add one to the result.


\subsection{Subtraction at work}
The key point of complement techniques is to convert subtraction into addition. So let us check that.

\paragraph{Examples.}
\ct{8 - 3 = 5}. The 10's complement of \ct{3} is \ct{9 - 3 + 1 = 7}. We add 8 to 7 and get 15. 
We drop the carry. So we obtain \ct{5}.


Now \ct{98-60}. The 10's complement of \ct{60} is \ct{9-6}, \ct{9-0} \ie \ct{39 + 1} \ie \ct{40}. 
\ct{98-60 = 98 + 40 - 100 = 138 - 100 - 38}.

\sd{should check the other subtraction because this is not clear yet to me.} 
Now performing \ct{60-98}. \ct{98} 10's complement is \ct{9-9}, \ct{9-8}, so \ct{2}.
\ct{60 - 98 = 60 + 2 - 100 = 62 - 100 = -38.}


\paragraph{Another look at it.} 
Imagine that we want to perform the following expression \ct{190680 - 109237} which is equals to \ct{81443}.
The 10's complement takes advantage of the fact that \ct{109237} is also \ct{999999 - 890762}.

\begin{code}{}
109237 = 999999 - 890762
109237 = 999999 - 890762 + 1 - 1
109237 = 1000000 - 890762 - 1
\end{code}

Now the first subtraction is expressed as:

\begin{code}{}
5006002 - 109237 = 5006002 - (1000000 - 890762 - 1)
= 5006002 - 1000000 + 890762 + 1
= 5006002  + 890762 + 1 - 1000000
\end{code}


\section{Two's complement of a number}



The two's complement is a common method to represent signed integers. The advantages are that addition and subtraction are implemented without having to  check the sign of the operands and two's complement has only one representation for zero (avoiding negative zero). 

What the 10's complement shows us  that it is achieved by taking the difference of each digit with the largest number available in the base system, 9 in decimal base and summing one. Now in the case of binary, it will be one.
Due to the fact that \ct{1 - 0 = 1} and \ct{1 - 1 = 0}, taking the complement of each digit is exactly the same as flipping 1's to 0's and vice versa.



\paragraph{Examples.}
The 2's complement of \ct{101} is \ct{111010}. Note here that the resulting number depends on the number of bits we have at hand.  

Now if we want to compute \ct{110110 - 101}. We will add 


110110 Ð 101

111111 Ð 000101 = 111010 (bit flipping of the subtrahend, 101)

110110 + 111010 + 1 = 1110001
1110001 Ð 1000000 = 110001

Therefore, 110110 Ð 101 = 110001


\paragraph{Representing negative numbers.}
What is nice with the 2's complement is that we can use it to represent a negative number. Indeed, we can negate a number by computing its two complement. The two's complement of a positive number represents a negative number of the number.

Let's look at 2. 2 is encoded on 8 bits as \ct{000000010} and \ct{-2} as \ct{11111110} as shown in Figure~\ref{negativePositive}.
\ct{000000010} flipped is: \ct{11111101} and we add one: so we get \ct{11111110}.
Now the difference between  -2 \ct{(11111110)} and 126 \ct{(01111110)} is given by the most significant bit. 

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.55\textwidth]{toRedo}
\caption{Please redo this picture. \label{negativePositive}}
\end{center}
\end{figure}

There is one exception. One a given number of bits, let's 8 bits as in Figure~\ref{negativePositive},
we obtained the negative of a number but computing its two's complement (flipping all the bits and adding 1), except for the most negative number. On a bits representation, the most negative number is -128 (1000 0000), inverting it is (0111 1111), and adding one results in (1000 0000). Why because we cannot encode 128 on 8 bits signed convention. 


\paragraph{In Pharo.}
Let's try with Pharo to check a bit our understanding. 

You can add the following method \ct{bitString} to the SmallInteger class. It returns a string of bit representing the bit representation of the receiver.

\begin{code}{}
SmallInteger>>bitString
	"Returns the bit representation of the receiver."
	""
	^ String streamContents: [:s | 
		30 to: 1 by: -1 do: [:i | s nextPut: ((self bitAt: i) + 48) asCharacter ] .
		s contents ]
\end{code}

\begin{code}{}
| v |
v := 10. 
String streamContents: [:s | 
	31 to: 1 by: -1 do: [:i | s nextPut: ((v bitAt: i) + 48) asCharacter   ] .
	s contents] 
	 '0000000000000000000000000001010'

| v |
v := -3.  "1111111111101"
String streamContents: [:s | 
	31 to: 1 by: -1 do: [:i | s nextPut: ((v bitAt: i) + 48) asCharacter   ] .
	s contents ]
	 '1111111111111111111111111111101' 
\end{code}
	
As we will below, Pharo small integers are encoded on 31 bits and the smallest (small integer) negative
integer is SmallInteger maxVal negated - 1. Here we see the exception of the most negative integer.

\begin{code}{} 
SmallInteger maxVal negated	 
	  	-1073741823
		
SmallInteger maxVal negated class
		SmallInteger

(SmallInteger maxVal + 1) class
		LargePositiveInteger		
		
(SmallInteger maxVal negated - 1) 
		-1073741824 (SmallInteger maxVal negated - 1)	class 
		SmallInteger 		 
\end{code}


\paragraph{A two's complement.}

Creating a two complement version of a number equals negating the number bits and adding one.
\begin{code}{Calculating two complement of 3}
3 bitString '0000000000000000000000000000011'
3 bitInvert bitString '1111111111111111111111111111100'
(3 bitInvert + 1) bitString '1111111111111111111111111111101'
-3 bitString '1111111111111111111111111111101'
\end{code}

\paragraph{Understanding more.}
Now you should be able to understand the implementation of \ct{SmallInteger>>bitInvert}

\begin{code}{}
SmallInteger>>bitInvert    "Answer an Integer whose bits are the logical negation of the receiver's bits.    Numbers are interpreted as having 2's-complement representation."	^ -1 - self.
\end{code}

\begin{code}{}
2 bitString
	'0000000000000000000000000000010'
2 bitInvert.
	'1111111111111111111111111111101'
	
-1 
	'1111111111111111111111111111111'
2 negated (two complement)
	'1111111111111111111111111111110'
\end{code}



\section{Hexadecimal}


\begin{code}
15 hex
	returns '16rF'
	
15 printStringHex 'F'

16rF
	returns 15
\end{code}


\begin{code}
(1 to: 15) collect: [:each | each -> each hex] 

{(1->'16r1'). (2->'16r2'). (3->'16r3'). (4->'16r4'). (5->'16r5'). (6->'16r6'). (7->'16r7'). (8->'16r8'). (9->'16r9'). (10->'16rA'). (11->'16rB'). (12->'16rC'). (13->'16rD'). (14->'16rE'). (15->'16rF')}
\end{code}


\begin{code}{}
16rF printStringBase: 2
	returns '1111'
\end{code}


\subsection*{Selecting a subpart}

\begin{code}{}
2r1100010100000000 
	returns 50432
\end{code}

Imagine that only 4 bits interest us starting at the 9th one.
We shift out the 8 first and clear all the others after the next 4.  

\begin{code}{}
(2r1100010100000000 >> 8)
	returns 2r11000101
	returns 197

(2r1100010100000000 >> 8) bitAnd: 16rF	
	returns 0101	
	returns 5
	
2r11000101 bitAnd: 1111
	returns 0101	
	returns 5
\end{code}


\section{SmallIntegers in Smalltalk}

Smalltalk small integers uses a two's complement arithmetic on 31 bits.  
An N-bit two's-complement numeral system can represent every integer in the range $-1 * 2^{N-1}\ to\ 2^{N-1}-1$. So for 32 bits Smalltalk systems, small integers values are the range -1073741824 to  1073741823. Let's check that a bit (this is the occasion to say it). 



If you want to know the number of bits used to represent a
SmallInteger, just evaluate:

\begin{code}
SmallInteger maxVal highBit + 1.
\end{code}

\ct{SmallInteger maxVal highBit} tells the highest bit which can be used to
represent a positive SmallInteger, and + 1 accounts for the sign bit
of the SmallInteger (0 for positive, 1 for negative).



\begin{code}{}
2 raisedTo: 29 
	returns 536870912 

536870912 class
	returns SmallInteger

2 raisedTo: 30 
	returns 1073741824

1073741824 class
	returns LargePositiveInteger

-1073741824 class 
	returns SmallInteger

2 class maxVal 
	returns 1073741823

-1 * (2 raisedTo: (31-1)) 
	returns -1073741824
	
(2 raisedTo: 30) - 1
	returns 1073741823
\end{code}








\section{Conclusion}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: