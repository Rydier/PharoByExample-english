% $Arnaud Jean-baptiste$
% $22 juin 2011 $
% $v1$

% HISTORY: []
% 2011-june-22 :: first commit


%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi


\newcommand{\opal}[0]{Opal~Compiler } % Ducasse
%=================================================================
\chapter{Opal Compiler} \chalabel{opal}

%\alex{I addressed lukas comments using editorial macros. Please, if you read this, remove this comment and remove the editorial macros, else their purpose is diminished}

\indexmain{opal}
\opal is a Smalltalk to Bytecode compiler for Pharo. This project was initiated to replace the original compiler, which slowly evolved from the one developed in the 80s. It was designed in one process Scanner/Parser. The result is the old compiler is hard to understand, to extend, and completely unadapted to the new needs. That's why the \opal project started. 

The \opal process, is built around 3 steps, covering all the steps from source code to the bytecode.

\begin{enumerate}
\item Source code to abstract syntax tree,
\item Abstract syntax tree to intermediary representation,
\item Intermediary representation to bytecode.
\end{enumerate}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{fullProcess}
	\caption{\opal complete compilation process. \figlabel{fullProcess}}
\end{figure}


\subsection{Loading Opal}

\opal will be the default compiler for Pharo. Right now we should load it to be able to execute the code snippets used in this chapter.

\begin{code}{}
Gofer
	...
	

\end{code}


\section{Abstract Syntax Tree process}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{SourceToAnnotatedAST}
	\caption{Source to AST Annotated \figlabel{SourceToAnnotatedAST}}
\end{figure}

The Abstract Syntax Tree (AST) is a tree representation of the source code. The AST is easy to manipulate and to visit. The AST used by \opal comes from Refactoring Engine. It uses \ct{RBParser} to generate ASTs, this step verifies the syntax.

The structure of an AST is a simple tree. Evaluate and explore the following expression:

\begin{code}{}
RBParser parseExpression: '1 + 2'.
"explore it"
\end{code}


\sd{so what do we see?}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\linewidth]{SimpleAtomicExpression}
	\caption{Generated Tree: '1 + 2'  \figlabel{SimpleAtomicExpression}}
\end{figure}

Let's try another example
\begin{code}{}
RBParser parseExpression: 'one plus: two'.
"inspect it"
\end{code}


\begin{figure}[ht]\centering
	\includegraphics[width=0.7\linewidth]{SimpleAtomicExpressionP}
	\caption{Tree generated : 'one plus: two' \figlabel{SimpleAtomicExpressionP}}
\end{figure}



\begin{code}{}
RBParser parseExpression: 'one plus: two plus: three'.
"inspect it"
\end{code}
\begin{figure}[ht]\centering
	\includegraphics[width=0.7\linewidth]{SimpleMultiExpression}
	\caption{Tree generated :  'one plus: two plus: three' \figlabel{SimpleMultiExpression}}
\end{figure}

You can also compile a Method and have a structure methodNode :
\begin{code}{}
RBParser parseMethod: 'xPlusY x + y'.
"inspect it"
\end{code}
\begin{figure}[ht]\centering
	\includegraphics[width=0.7\linewidth]{ASTbeforeSemanticAnalysis}
	\caption{Tree generated :  'xPlusY x + y' \figlabel{ASTbeforeSemanticAnalysis}}
\end{figure}


\subsubsection{Annotated the Abstract Syntax Tree}
Then we do the semantic analysis on the AST. The goal of the semantic analysis is to add semantic data to the generated tree. One of the key function of the semantic analysis is to bind the variable. Because the as we see before the AST check only the \emph{syntax} of the code. That check the semantic of the code. If in context of the specific class this code is valid. If a variable is undeclared or used out of scope, a message is send to the UI. 
The graph is annotated by visiting the graph by two visitor :
\begin{itemize}
\item OCASTSemanticAnalyzer : do the var binding
\item OCASTClosureAnalyzer : do the closure analysis
\end{itemize}
let try a Example :

\begin{code}{}
ast :=RBParser parseExpression: '1 + 2'.
"visit and annotated the AST for the closure analysis "
OCASTClosureAnalyzer new visitNode: ast.
"visit and annotated the AST for the var binding"
OCASTSemanticAnalyzer new
		scope: Object parseScope;
		visitNode: ast.
ast. "inspect It"
\end{code}
All the data of binding is inject in AST, when you inspect your AST you can see the value properties is now set to a RBSmallDictionary 




\subsection{Intermediary Representation}
At the specific step of the compilation process, we have a AST annotated with semantic data. We need to translate it into a intermediary representation. The Intermediary Representation is a bytecode structured in tree. It is easy to manipulate more than the bytecode itself, and really close of the generated bytecode. Usually the bytecode optimization will be injected at this step.
 
\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{AnnotatedASTToIR}
	\caption{AST Annotated to Intermediary Representation \figlabel{AnnotatedASTToIR}}
\end{figure}

As we have a AST structure, it is easy to transform AST to Intermediary Representation(IR). The IR have a builder IRBuilder, that offer all the infrastructure to add each possible node. We apply the pattern visitor to the AST to build the corresponding IR. ASTTranslator will visit each node and for each node will build the corresponding IR node sequence.


\subsection{Bytecode}
At the specific step of the compilation process, we have the IR generated, once again to transform the IR in bytecode we apply the pattern visitor on the IR tree, the IR tree is close to the bytecode, then we just visit each node and push then corresponding bytecode.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{IRToBytecode}
	\caption{Intermediary Representation to Bytecode \figlabel{IRToBytecode}}
\end{figure}

\section{Decompilation}
Such the compilation process

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%Other stuff:
%- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
%- collect direct senders; class collaborations
%- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)
%- PointerFinder?
%- anonymous classes (see slides) ?

%Test  Coverage using ObjectsAsMethodsWrap package:
%\begin{code}{}
%category := 'SCGPier'.
%w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
%tr := TestRunner new.
%ToolBuilder open: tr.
%[tr
%	categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
%	selectAllClasses;
%	runAll.]
%ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
%((w select: [:each | each executed not ])
%	collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
%\end{code}
