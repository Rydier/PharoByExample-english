% $Arnaud Jean-baptiste$
% $22 juin 2011 $
% $v1$

% HISTORY: []
% 2011-june-22 :: first commit


%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	%\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi


\newcommand{\opal}[0]{Opal~Compiler } % Ducasse
%=================================================================
\chapter{Opal Compiler} \chalabel{opal}

%\alex{I addressed lukas comments using editorial macros. Please, if you read this, remove this comment and remove the editorial macros, else their purpose is diminished}

\indexmain{opal}
\opal is a Smalltalk to Bytecode compiler for Pharo. This project was initiated to replace the original compiler, which slowly evolved from the one developed in the 80s. It was designed in one process Scanner/Parser. The result is the old compiler is hard to understand, to extend, and completely unadapted to the new needs. That's why the \opal project started. 

The \opal process, is built around 3 steps, covering all the steps from source code to the bytecode.

\begin{enumerate}
\item Source code to abstract syntax tree,
\item Abstract syntax tree to intermediary representation,
\item Intermediary representation to bytecode.
\end{enumerate}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{fullProcess}
	\caption{\opal complete compilation process. \figlabel{fullProcess}}
\end{figure}


\subsection{Loading Opal}

\opal will be the default compiler for Pharo. Right now we should load it to be able to execute the code snippets used in this chapter.

\begin{code}{}
Gofer
	...
	

\end{code}


\section{Abstract Syntax Tree process}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{SourceToAnnotatedAST}
	\caption{Source to AST Annotated \figlabel{SourceToAnnotatedAST}}
\end{figure}

The Abstract Syntax Tree (AST) is a tree representation of the source code. The AST is easy to manipulate and to visit. The AST used by \opal comes from Refactoring Engine. It uses \ct{RBParser} to generate ASTs, this step verifies the syntax.

The structure of an AST is a simple tree. Evaluate and explore the following expression:

\begin{code}{}
t := RBParser parseExpression: '1 + 2'.
"explore it"

\end{code}


\sd{so what do we see? we should add t something }

Using the message \ct{parseExpression:} we get an AST representing the expression.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\linewidth]{SimpleAtomicExpression}
	\caption{Generated tree for  '1 + 2'  \figlabel{SimpleAtomicExpression}}
\end{figure}

Let's try another example
\begin{code}{}
RBParser parseExpression: 'one plus: two'.
"inspect it"
\end{code}


\begin{figure}[ht]\centering
	\includegraphics[width=0.7\linewidth]{SimpleAtomicExpressionP}
	\caption{Generated tree for  'one plus: two' \figlabel{SimpleAtomicExpressionP}}
\end{figure}



\begin{code}{}
RBParser parseExpression: 'one plus: two plus: three'.
"inspect it"
\end{code}
\begin{figure}[ht]\centering
	\includegraphics[width=0.7\linewidth]{SimpleMultiExpression}
	\caption{Generated tree for  'one plus: two plus: three' \figlabel{SimpleMultiExpression}}
\end{figure}

You can also compile a method using the message \ct{parseMethod:} instead of \ct{parseExpression:}. We will get a methodNode object:

\begin{code}{}
RBParser parseMethod: 'xPlusY x + y'.
"inspect it"
\end{code}


\sd{so what do we see? we should add t something }

\begin{figure}[ht]\centering
	\includegraphics[width=0.7\linewidth]{ASTbeforeSemanticAnalysis}
	\caption{Generated tree for  'xPlusY x + y' \figlabel{ASTbeforeSemanticAnalysis}}
\end{figure}


\subsubsection{Annotated the Abstract Syntax Tree}

Once parsed we can perform a semantic analysis of the AST. The goal of a semantic analysis is to add semantic data to the generated tree. One of the key function of the semantic analysis is to bind variables. 
Because as we see before the AST only checks the \emph{syntax} of the code. A semantic analysis  checks the semantics of the code: for example, if in context of a specific class, the code is valid. We can identify if a variable is undeclared or used out of scope, or if a message is send to the UI. 

The AST is annotated by visiting the graph by two visitors:
\begin{itemize}
\item \ct{OCASTSemanticAnalyzer} performs the variable binding.
\item \ct{OCASTClosureAnalyzer} performs the closure analysis.
\end{itemize}

Let's try an example:

\begin{code}{}
|ast|
ast := RBParser parseExpression: '1 + 2'.

"visit and annotated the AST for the closure analysis "
OCASTClosureAnalyzer new visitNode: ast.
"visit and annotated the AST for the var binding"

OCASTSemanticAnalyzer new
		scope: Object parseScope;
		visitNode: ast.
ast. "inspect It"
\end{code}

\sd{what do we get?}

All the data of binding is injected in the AST, when you inspect your AST you can see the value properties is now 
set to a dictionary. \sd{show it}




\subsection{Intermediary Representation}
At the specific step of the compilation process, we have a AST annotated with semantic data. We need to translate it into a intermediary representation. The Intermediary Representation is a bytecode structured in tree. It is easy to manipulate more than the bytecode itself, and really close of the generated bytecode. Usually the bytecode optimization will be injected at this step.
 
\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{AnnotatedASTToIR}
	\caption{AST Annotated to Intermediary Representation \figlabel{AnnotatedASTToIR}}
\end{figure}

As we have a AST structure, it is easy to transform AST to Intermediary Representation(IR). The IR have a builder IRBuilder, that offer all the infrastructure to add each possible node. We apply the pattern visitor to the AST to build the corresponding IR. ASTTranslator will visit each node and for each node will build the corresponding IR node sequence.


\subsection{Bytecode}
At the specific step of the compilation process, we have the IR generated, once again to transform the IR in bytecode we apply the pattern visitor on the IR tree, the IR tree is close to the bytecode, then we just visit each node and push then corresponding bytecode.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{IRToBytecode}
	\caption{Intermediary Representation to Bytecode \figlabel{IRToBytecode}}
\end{figure}

\section{Decompilation}
Such the compilation process

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%Other stuff:
%- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
%- collect direct senders; class collaborations
%- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)
%- PointerFinder?
%- anonymous classes (see slides) ?

%Test  Coverage using ObjectsAsMethodsWrap package:
%\begin{code}{}
%category := 'SCGPier'.
%w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
%tr := TestRunner new.
%ToolBuilder open: tr.
%[tr
%	categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
%	selectAllClasses;
%	runAll.]
%ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
%((w select: [:each | each executed not ])
%	collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
%\end{code}
