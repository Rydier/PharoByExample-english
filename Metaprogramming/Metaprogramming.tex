% $Author$
% $Date$
% $Revision$

% HISTORY: [see also Metaprogramming2.tex]
% 2007-05-22 - Damien Pollet started (translation from French article by ...?)
% 2008-01-15 - Alex added text
% 2008-12-15 - Oscar revised
% 2009-03-24 - Stef started new chapter (acttalk ... see separate file)
% 2009-06-01 - Oscar started to revise again and add new material

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6in,9in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Introspection and metaprogramming}\label{cha:metaprog}

\on{I am revising this chapter}

\lr{Hi Oscar,
I think that would be valuable information to add to the meta-programming chapter. Otherwise beginners will run into troubles when they try to do some reflective tricks on these messages.
Selectors that are never sent:\\
	class yourself \\
Selectors that have a special shortcut behavior. Depending on the receiver they are sometimes not looked up but directly invoke the primitive:\\
	+ - < > <= >= = ~= * / $\backslash$ ==
	@ bitShift: // bitAnd: bitOr:
	at: at:put: size
	next nextPut: atEnd
	blockCopy: value value: do: new new: x y \\
Selectors that are never send, because inlined by the compiler and transformed to comparison and jump bytecodes:\\
	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
	and: or:
	whileFalse: whileTrue: whileFalse whileTrue
	to:do: to:by:do:
	caseOf: caseOf:otherwise:
	ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:\\
Interesting is that attempts to send these messages to non boolean objects can be intercepted and execution can be resumed with a valid boolean value by overriding \#mustBeBoolean in the receiver or by catching the NonBooleanReceiver exception.\\
Cheers,
Lukas
}

\st is a reflective programming language.
In a nutshell, this means that programs are able to reflect on their own execution.
A program that manipulates other programs (or even itself) is a \emph{metaprogram}.
For a programming language to be reflective, it should support both \emph{introspection} and \emph{intercession}.
Introspection is the ability to \emph{examine} the data structures that define the language, such as objects, classes, methods and the execution stack.
Intercession is the ability to \emph{modify} these structures, in other words to change the language semantics and the behavior of a program from within the program itself.

In this chapter we will explore many practical examples illustrating how \st supports introspection and metaprogramming.

%:======================================
\section{Introspection}

Using the inspector, you can look at an object, change the values of its instance variables, and even send messages to it.

\dothis{Evaluate the following code in a workspace:}
\begin{code}{| w |}
w := Workspace new.
w openLabel: 'My Workspace'.
w inspect
\end{code}

This will open a second workspace and an inspector.
The inspector shows the internal state of this new workspace, listing its instance variables in the left part (\ct!dependents!, \ct!contents!, \ct!bindings!...) and the value of the selected instance variable in the right part.
The \ct!contents! instance variable represents whatever the workspace is displaying in its text area, so if you select it, the right part will show an empty string.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{workspaceInspector}
	\caption{Inspecting a \ct!Workspace!.\label{fig:workspaceInspector}}
\end{figure}

\dothis{Now type \ct!'hello'! in place of that empty string, then \emph{accept} it.}
The value of the \ct!contents! variable will change, but the workspace window will not notice it, so it does not redisplay itself.
To trigger the window refresh, evaluate \ct!self contentsChanged! in the lower part of the inspector.

%-----------------------------------------------------------------
\subsection{Accessing instance variables}

How does the inspector work?
In \st, all instance variables are protected.
In theory, it is impossible to access them if the class doesn't define any accessor.
In practice, the inspector can access instance variables without needing accessors, because it uses the reflective abilities of \st.
In \st, classes define instance variables either by name or by numeric indices.
The inspector uses methods defined by the \ct!Object! class to access them: \lct{instVarAt: \emph{index}} and \lct{instVarNamed: \emph{aString}} can be used to get the value of the instance variable at position \lct{\emph{index}} or identified by \lct{\emph{aString}}, respectively; to assign new values to these instance variables, it uses \ct!instVarAt:put:! and \ct!instVarNamed:put:!.

For instance, you can change the value of the \ct!w! instance variable of the first workspace by evaluating:
\begin{code}{}
w instVarNamed: 'contents' put: 'howdy!'; contentsChanged
\end{code}

\emph{Caveat:} Although these methods are useful for building development tools, using them to develop conventional applications is a bad idea: these reflective methods break the encapsulation boundary of your objects and can therefore make your code much harder to understand and maintain.

Both \ct!instVarAt:! and \ct!instVarAt:put:! are primitive methods, meaning that they are implemented as primitive operations of the \pharo virtual machine.
If you consult the code of these methods, you will see the special syntax \ct!<primitive: xx>! where \ct!xx! is an integer.

\needlines{5}
\begin{code}{}
Object>>>instVarAt: index 
	"Primitive. Answer a fixed variable in an object. ..."
	!\textbf{<primitive: 73>}!
	"Access beyond fixed variables."
	^self basicAt: index - self class instSize		
\end{code}

Typically, the code after the primitive invocation is not executed.
It is executed only if the primitive fails. In this specific case, if we try to access a variable that does not exist, then the code following the primitive will be tried.
This also allows the debugger to be started on primitive methods.
Although it is possible to modify the code of primitive methods, beware that this is a quite risky business for the stability of your \pharo system.

%There is a limited number of primitive operations in \pharo. They constitute the basic actions in \st: basic operations on integers, accessing input/output peripherals (disk, screen, network...).
%Some of these primitives also accelerate system functions.
%It is also possible to define custom primitives and to link them to plugins written in C to benefit from external libraries or from the speed of a native implementation.

\begin{figure}[ht]\centering
	\includegraphics[width=0.8\linewidth]{allInstanceVariables}
	\caption{Displaying all instance variables of a \ct!Workspace!.\label{fig:allInstanceVariables}}
\end{figure}

\figref{allInstanceVariables} shows how to display the values of the instance variables of an arbitrary instance (\ct!w!) of class \ct!Workspace!.
The method \ct!allInstVarNames! returns all the names of the instance variables of a given class.

In the same spirit, it is possible to gather instances that have specific properties.
%For instance, to get all instances of class \ct!Browser! whose instance variable \ct!systemOrganizer! is not \ct!nil!, try this expression:
For instance, to get all instances of class \ct!SketchMorph! whose instance variable \ct!owner! is set to the world morph (\ie images currently displayed), try this expression:
\begin{code}{}
SketchMorph allInstances select: [:c | (c instVarNamed: 'owner') isWorldMorph]
\end{code}
% Browser allInstances select: [:c | (c instVarNamed: 'systemOrganizer') notNil]

%-----------------------------------------------------------------
\subsection{Iterating over instance variables}

Let us consider the message \ct!instanceVariableValues!, which returns a collection of all values of instance variables defined by this class, excluding the inherited instance variables.
For instance:
\begin{code}{@TEST}
(1@2) instanceVariableValues --> an OrderedCollection(1 2)
\end{code}

The method is implemented in \ct{Object} as follows:
\needlines{9}
\begin{code}{}
Object>>>instanceVariableValues
	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class."	
	| c |
	c := OrderedCollection new.
	self class superclass instSize + 1
		to: self class instSize
		do: [ :i | c add: (self instVarAt: i)].
	^ c
\end{code}

This method iterates over the indices of instance variables that the class defines, starting just after the last index used by the superclasses.
(The method \ct!instSize! returns the number of all named instance variables that a class defines.)

%-----------------------------------------------------------------
\subsection{Querying classes and interfaces}

The development tools in \pharo (code browser, debugger, inspector...) all use the reflective features we have seen so far.

Here are a few other messages that might be useful to build development tools:

\lct{isKindOf: \emph{aClass}} returns true if the receiver is instance of \lct{\emph{aClass}} or of one of its superclasses.

For instance:
\begin{code}{@TEST}
1.5 class                     --> Float
1.5 isKindOf: Number --> true
1.5 isKindOf: Integer   --> false
\end{code}

\lct{respondsTo: \emph{aSymbol}} returns true if the receiver has a method whose selector is \lct{\emph{aSymbol}}.

For instance:
\needlines{3}
\begin{code}{@TEST}
1.5 respondsTo: #floor      --> true    "since Number implements floor"
1.5 floor                            --> 1
Exception respondsTo: #, --> true    "exception classes can be grouped"
\end{code}

\emph{Caveat:} Although these features are especially useful for defining development tools, they are normally not appropriate for typical applications.
Asking an object for its class, or querying it to discover which messages it understands, are typical signs of design problems, since they violate the principle of encapsulation.
Development tools, however, are not normal applications, since their domain is that of software itself. As such these tools have a right to dig deep into the internal details of code.

There also exist mechanisms for introspecting on various parts of the run-time system, such as  the process scheduler, the memory manager and so on. For now we will focus on navigating through objects, classes and methods, and we will look more closely at rest of the runtime system in an other chapter.

%-----------------------------------------------------------------
\subsection{Code metrics}

Let's see how we can use \st's introspection features to quickly extract some code metrics.
Code metrics measure some aspect of program code such as depth of the inheritance hierarchy, the number of direct or indeirect subclasses, the number of methods or of instance variables in each class, or the number of locally defined methods or instance variables.
Here are a few metrics for the class \ct!Morph!, which is the superclass of all graphical objects in \pharo, revealing that it is a huge class, and that it is at the root of a huge hierarchy. Maybe it needs some refactoring!

\begin{code}{}
Morph allSuperclasses size.  -->       2 "inheritance depth"
Morph allSelectors size.        --> 1378 "number of methods"
Morph allInstVarNames size. -->      6 "number of instance variables"
Morph selectors size.             -->  998 "number of new methods"
Morph instVarNames size.     -->      6 "number of new variables"
Morph subclasses size.          -->    45 "direct subclasses"
Morph allSubclasses size.      -->  326 "total subclasses"
\end{code}

One of the most interesting metrics in the domain of object-oriented languages is the number of methods that extend methods inherited from the superclass.
This informs us about the relation between the class and its superclasses.

%:======================================
\section{Browsing code}

In \st, everything is an object. In particular, classes are objects that provide useful features for navigating through their instances.
Most of the messages we will look at now are implemented in \ct{Behavior}, so they are understood by all classes.

As we saw previously, you can obtain an instance of a given class by sending it the message \ct!#someInstance!.

\begin{code}{@TEST} % Possibly fragile!
Point someInstance --> 0@0
\end{code}

You can also gather all the instances with \ct!#allInstances!, or the number of alive instances in memory with \ct!#instanceCount!.

\begin{code}{} % Cannot test this
ByteString allInstances     --> #('collection' 'position'  ...)
ByteString instanceCount --> 104565
\end{code}

These features can be very useful when debugging an application, because you can ask a class to enumerate those of its methods exhibiting specific properties.
\begin{itemize}
\item \ct!whichSelectorsAccess:! returns the list of all selectors of methods that read the instance variable named as the argument
\item \ct!whichSelectorsStoreInto:! returns the selectors of methods that modify the value of an instance variable
\item \ct!whichSelectorsReferTo:! returns the selectors of methods that send a given message
\item \ct!crossReference! associates each message with the set of methods that send it.
\end{itemize}

%\ct!an IdentitySet(#rotateBy:about: #translateBy: #isInsideCircle:with:with: #sideOf: #nearestPointAlongLineFrom:to: #normalized #eightNeighbors #dist: #hash #rotateBy:centerAt: #theta #grid: #fourNeighbors #dotProduct: #scaleFrom:to: #normal #onLineFrom:to:within: #+ #degrees #interpolateTo:at:)!.

\begin{code}{} % TOO FRAGILE TO TEST
Point whichSelectorsAccess: 'x'    --> an IdentitySet(#'\\' #= #scaleBy: ...)
Point whichSelectorsStoreInto: 'x' --> an IdentitySet(#setX:setY: ...)
Point whichSelectorsReferTo: #+  --> an IdentitySet(#rotateBy:about: ...)
Point crossReference --> an Array(
		an Array('*' an IdentitySet(#rotateBy:about: ...))
		an Array('+' an IdentitySet(#rotateBy:about: ...))
		...)
\end{code}

The following messages take inheritance into account:
\begin{itemize}
\item \ct{whichClassIncludesSelector:} returns the superclass that implements the given message
\item \ct{unreferencedInstanceVariables} returns the list of instance variables that are neither used in the receiver class nor any of its subclasses
\end{itemize}

\begin{code}{@TEST}
Rectangle whichClassIncludesSelector: #inspect --> Object
Rectangle unreferencedInstanceVariables            --> #()
\end{code}

\ct{SystemNavigation} is a facade that supports various useful methods for querying and browsing the source code of the system.
\ct!SystemNavigation default! returns an instance you can use to navigate the system.
For example:

\begin{code}{@TEST}
SystemNavigation default allClassesImplementing: #yourself --> {Object}
\end{code}

%\ct!SystemNavigation default allClassesImplementing: #+! returns all classes that implement the message \ct!#+!.
%	In this case we get \ct!an Array(Number Fraction Float Integer SmallInteger LargePositiveInteger ScaledDecimal DateAndTime Duration Timespan Player Color Collection WordArray FloatArray KedamaFloatArray String Interval AbstractSound MixedSound Point Voice Complex TraitDescription TraitComposition TraitTransformation TComposingDescription)!.
%	As you can see, it is possible to add integers, fractions, strings or intervals.

The following messages should also be self-explanatory:

\begin{code}{}
SystemNavigation default allSentMessages size          --> 24930
SystemNavigation default allUnsentMessages size      --> 6431
SystemNavigation default allUnimplementedCalls size --> 270
\end{code}

Note that messages implemented but not sent are not necessarily useless, since they may be sent implicitly (\eg using \ct{perform:}).
Messages sent but not implemented, however, are more problematic, because the methods sending these messages will fail at runtime.
They may be a sign of unfinished implementation, obsolete APIs, or missing libraries.

\ct!SystemNavigation default allCallsOn: #Point! returns all messages sent explicitly to \ct!Point! as a receiver.

All these features are integrated in the programming environment of \pharo, in particular in the code browsers.
As you should already be aware, there are convenient keyboard shortcuts for browsing all i\underline{m}plementors (\short{m}) and se\underline{n}ders (\short{n}) of a given message.
What is perhaps not so well known is that there are many such pre-packaged queries implemented as methods of the \ct{SystemNavigation} class in the \prot{browsing} protocol.
For example, you can programmatically browse all implementors of the message \ct{ifTrue:} by evaluating:
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #ifTrue:
\end{code}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{implementors}
	\caption{Browse all implementations of \ct!\#ifTrue:!.\label{fig:implementors}}
\end{figure}

Particularly useful are the methods \ct{browseAllSelect:} and \ct{browseMethodsWithSourceString:}.  Here are two different ways to browse all methods in the system that perform super sends (the first way is rather brute force; the second way is better and eliminates some false positives):
\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'super'.
SystemNavigation default browseAllSelect: [:method | method sendsToSuper ].
\end{code}

%:======================================
\section{Classes, method dictionaries and methods}

Since classes are objects, we can inspect or explore them just like any other object.

\dothis{Evaluate \ct{Point explore}.}

In \figref{CompiledMethod}, the explorer shows the structure of class \ct!Point!.
You can see that the class stores its methods in a dictionary, indexing them by their selector.
The selector \ct{#*} points to the decompiled bytecode of \ct!Point>>>*!.

\begin{figure}[ht]\centering
	\includegraphics[width=.5\linewidth]{CompiledMethod}
	\caption{Explorer class \ct!Point! and the bytecode of its \ct!\#*! method.\label{fig:CompiledMethod}}
\end{figure}

% ON: THIS DISCUSSION DOES NOT BELONG HERE
%\st is really a completely open and transparent system, where all the code is available for reading.
%You can study the whole system as you wish, because there is no hidden code.
%The primitive part of the system, \ie which is not written in \st, is reduced to its simplest expression.
%Among \st dialects, \pharo has the peculiarity that even its virtual machine is written in \st, so it is possible to run and debug it inside a \pharo image!
%Though this actually works, it is quite slow, and for actual use the virtual machine is translated to C and compiled to a native executable.

Let us consider the relationship between classes and methods.
In \figref{MethodsAsObjects} we see that classes and metaclasses have the common superclass \ct{Behavior}. This is where \ct{new} is defined, amongst other key methods for classes.
Every class has a method dictionary, which maps method selectors to compiled methods.
Each compiled method knows the class in which it is installed.
In \figref{CompiledMethod} we can even see that this is stored in an association in \ct{literal5}.

\begin{figure}[ht]\centering
	\includegraphics[width=0.8\linewidth]{MethodsAsObjects}
	\caption{Classes, method dictionaries and compiled methods\label{fig:MethodsAsObjects}}
\end{figure}

We can exploit the relationships between classes and methods, to pose queries about the system.
For example, to discover which methods are newly introduced in a given class, \ie do not override superclass methods, we can navigate from the class to the method dictionary as follows:
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger
  --> an IdentitySet(#threeDigitName #printStringBase:nDigits: ...)
\end{code}

A compiled method does not simply store the bytecode of a method.
It is also an object the provides numerous useful methods for querying the system.
One such method is \ct{isAbstract} (which tells if the method sends \ct{subclassResponsibility}).
We can use it to identify all the abstract methods of an abstract class
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass>>aMethod) isAbstract ]] value: Number
  --> an IdentitySet(#storeOn:base: #printOn:base: #+ #- #* #/ ...)
\end{code}
Note that this code sends the \ct{>>} message to a class to obtain the compiled method for a given selector.

As a slightly more complex example, we can browse 

To browse the super-sends within a given hierarchy, for example within the Collections hierarchy, we can pose a more sophisticated query:
\begin{code}{}
class := Collection.
SystemNavigation default
  browseMessageList: (class withAllSubclasses gather: [:each |
    each methodDict associations
      select: [:assoc | assoc value sendsToSuper]
      thenCollect: [:assoc | MethodReference class: each selector: assoc key]])
  name: 'Supersends of ' , class name , ' and its subclasses'
\end{code}
Note how we navigate from classes to method dictionaries to compiled methods to identify the methods we are interested in.
A \ct{MethodReference} is a lightweight proxy for a compiled method that is used by many tools.

%:======================================
\section{Browsing environments}

Although \ct{SystemNavigation} offers some useful ways to programmatically query and browse system code, there is a better way.  The Refactoring Browser, which is integrated into \pharo, provides both interactive and programmatic ways to pose complex queries.

Suppose we are interested to discover which methods in the \ct{Collection} hierarchy send a message to \super which is different from the method's selector.
This is normally considered to be a bad code smell, since such a \super-send should normally be replaced by a \self-send. (Think about it --- you only \emph{need} \super to extend a method you are overriding; all other inherited methods can be accessed by sending to \self!)

The refactoring browser provides us with an elegant way to restrict our query to just the classes and methods we are interested in.

\dothis{Open a system browser on the class \ct{Collection}.
\actclick on the class name and select \menu{refactoring scope>subclasses with}.
This will open a new Browser Environment on just the \ct{Collection} hierarchy.
Within this restricted scope select \menu{refactoring scope>super-sends} to open a new environment with all methods that perform super-sends within the \ct{Collectuon} hierarchy.
Now \click on any method and select \menu{refactor>code critics}.
Navigate to \menu{Lint checks>Possible bugs>Sends different super message} and \actclick to select \menu{browse}.}

In \figref{sendDifferentSuper} we can see that 19 such methods have been found within the \ct{Collection} hierarchy, including \ct{Collection>>>printNameOn:}, which sends \ct{super printOn:}.
\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{sendDifferentSuper}
	\caption{Finding methods that send a different super message.\label{fig:sendDifferentSuper}}
\end{figure}

Browser environments can also be created programmatically.
Here, for example, we create a new \ct{BrowserEnvironment} for \ct{Collection} and its subclasses, select the super-sending methods, and open the resulting environment.
\needlines{4}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | method sendsToSuper])
	label: 'Collection methods sending super';
	open.
\end{code}{}

Note how this is considerably more compact than the earlier, equivalent example using \ct{SystemNavigation}.

Finally, we can find just those methods that send a different super message programmatically as follows:
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | 
		method sendsToSuper
		and: [(method parseTree superMessages includes: method selector) not]])
	label: 'Collection methods sending different super';
	open
\end{code}
Here we ask each compiled method for its (Refactoring Browser) parse tree, in order to find out whether the super messages differ from the method's selector.
Look at the \prot{querying} protocol of the class \ct{RBProgramNode} to see some the things we can ask of parse trees.

%:======================================
\section{Accessing the run-time context}

We have seen how \st's reflective capabilities let us query and explore objects, classes and methods.  But what about the run-time environment?

%-----------------------------------------------------------------
\subsection{Method Contexts}

In fact, the run-time context of an executing method is in the virtual machine --- it is not in the image at all.
On the other hand, the debugger obviously has access to this information, and we can happily explore the run-time context, just like any other object.
How is this possible?

Actually, there is nothing magical about the debugger.
The secret is the pseudo-variable \ct{thisContext}, which we have encountered only in passing before.
Whenever \ct{thisContext} is referred to in a running method, the entire run-time context of that method is reified and made available as \ct{MethodContext} objects to the image.

We can easily experiment with this mechanism ourselves.

\dothis{Change the definition of \ct{Integer>>>factorial} by inserting the underlined expression as shown below:}

\begin{code}{}
Integer>>>factorial
	"Answer the factorial of the receiver."
	self = 0 ifTrue: [!\underline{thisContext explore. self halt.}! ^ 1].
	self > 0 ifTrue: [^ self * (self - 1) factorial].
	self error: 'Not valid for negative integers'
\end{code}

\dothis{Now evaluate \ct{3 factorial} in a workspace. You should see both a pre-debugger window and an explorer, as shown in \figref{exploringThisContext}.}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{exploringThisContext}
	\caption{Exploring \lct{thisContext}.\label{fig:exploringThisContext}}
\end{figure}

If you now browse the class of the explored object (\ie by evaluating \ct{self browse} in the bottom pane of the explorer) you will discover that it is an instance of the class \ct{MethodContext}, as is each \ct{sender} in the chain. All of these objects have been created dynamically in the image by the \st virtual machine at the point where \ct{thisContext} was referred to in the \ct{factorial} method.

\ct{thisContext} is not intended to be used for day-to-day programming, but it is essential for implementing tools like debuggers, and for accessing information about the call stack.
You can evaluate the following expression to discover which methods make use of \ct{thisContext}:

\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'thisContext'
\end{code}

As it turns out, one of the most common applications is to discover the sender of a message.
Here is a typical application:

\begin{code}{}
Object>>>subclassResponsibility
	"This message sets up a framework for the behavior of the class' subclasses.
	Announce that the subclass should have implemented this message."

	self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{code}

By convention, methods in \st that send \ct{self subclassResponsibility} are considered to be abstract.  But how does \ct{Object>>>subclassResponsibility} provide a useful error message indicating which abstract method has been invoked?  Very simply, by asking \ct{thisContext} for the sender.

%-----------------------------------------------------------------
\subsection{Intelligent breakpoints}

The \st way to set a breakpoint is to evaluate \ct{self halt} at an interesting point in a method.  This will cause \ct{thisContext} to be reified, and a debugger window will open at the breakpoint.
Unfortunately this poses problems for methods that are intensively used in the system.

Suppose, for instance, that we want to explore the execution of \ct{OrderedCollection>>>add:}.
Setting a breakpoint in this method is problematic.

\dothis{Take a \emph{fresh} image and set the following breakpoint:}
\needlines{3}
\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self halt.}!
	^self addLast: newObject
\end{code}

Notice how your image immediately freezes!  We do not even get a debugger window.
The problem is clear once we understand that (i) \ct{OrderedCollection>>>add:} is used by many parts of the system, so the breakpoint is triggered very soon after we accept the change, but (ii) the debugger itself sends \ct{add:} to an instance of \ct{OrderedCollection}, preventing the debugger from opening.
What we need is a way to \emph{conditionally halt} only if we are in a context of interest.
This is exactly what \ct{Object>>haltIf:} offers.

Suppose now that we only want to halt if \ct{add:} is sent from, say, the context of \ct{OrderedCollectionTest>>>testAdd}.

\dothis{Fire up a fresh image again, and set the following breakpoint:}
\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self haltIf: \#testAdd.}!
	^self addLast: newObject
\end{code}

This time the image does not freeze. Try running the \ct{OrderedCollectionTest}.
(You can find it in the \cat{CollectionsTests-Sequenceable} category.)

How does this work?  Let's have a look at \ct{Object>>>haltIf:}:

%\on{talk about squeak here?} In the 3.8 version of \squeak introduced a new kind of breakpoints.
%Those are quite useful and are implemented by the \ct!Object>>>haltIf:! method.
%This breakpoint only halts program execution if the method it's placed in was called by the one whose name was passed as an argument.
%This is very useful to halt a method only during the execution of a test and not every time it is called.
%For instance, the expression \ct!self haltIf: #testFoo! will only halt execution of its containing method if this method was called, directly or indirectly, from \ct!testFoo!.
%The definition of \ct!haltIf:! is quite simple and fits in five lines; it uses the pseudo-variable \ct!thisContext!, which refers to the execution stack, represented as an object (\ct!thisContext! is one of the six keywords in \st, with \self, \super, \nil, \ct!true!, and \ct!false!).

\begin{code}{}
Object>>>haltIf: condition
	| cntxt |
	condition isSymbol ifTrue: [
		"only halt if a method with selector symbol is in callchain"
		cntxt := thisContext.
		[cntxt sender isNil] whileFalse: [
			cntxt := cntxt sender. 
			(cntxt selector = condition) ifTrue: [Halt signal]. ].
		^self.
	].
	...
\end{code}

Starting from \ct!thisContext!, \ct!haltIf:! goes up through the execution stack, checking if the name of the calling method is the same as the one passed as parameter.
If this is the case, then it raises an exception which, by default, summons the debugger.

It is also possible to supply a boolean or a boolean block as an argument to \ct{haltIf:}, but these cases are straightforward and do not make use of \ct{thisContext}.

%This example shows the power of \st, which allows to define powerful features and tools from within the language itself.

%The pseudo-variable \ct!thisContext! is especially used in the \pharo debugger.
%It contains an instance of the \clsind{MethodContext} class.
%This instance contains information about the method that is being executed, the stack pointer (\ct!stackpc!), and the program pointer (\ct!pc!).

%In the following example, we halted \pharo's evaluation loop by pressing \short{.} and inspecting the current context.

%\begin{figure}[ht]\centering
%	\includegraphics[width=\linewidth]{MethodContext}
%	\caption{Inspecting the execution context of the evaluation loop in \pharo.\label{fig:MethodContext}}
%\end{figure}

%Via \ct!thisContext!, the Seaside web framework also accesses the execution stack, but it modifies it on the fly to easily implement reusable components over HTTP.

%:======================================
\section{Intercepting doesNotUnderstand}

So far we have used the reflective features of \st mainly to query and explore objects, classes, methods and the run-time stack. Now we will look at how to use our knowledge of the \st system structure to modify behaviour at run-time.

As we have seen in \charef{model}, when an object receives a message, it first looks in the method dictionary of its class for a corresponding method to respond to the message.
If no such method exists, it will continue looking up the class hierarchy, until it reaches \ct{Object}. If still no method is found for that message, the object will send itself the message \ct{doesNotUnderstand:} with the message selector as its argument.
The process then starts all over again, until \ct{Object>>>doesNotUnderstand:} is found, and the debugger is launched.

But what if \ct{doesNotUnderstand:} is overridden by one of the subclasses of \ct{Object} in the lookup path?
As it turns out, this is a convenient way of realizing certain kinds of very dynamic behaviour. An object that does not understand a message can, by overriding \ct{doesNotUnderstand:}, fall back to an alternative strategy for responding to that message.

Two very common applications of this technique are (1) to implement lightweight proxies for objects, and (2) to dynamically compile or load missing code.
In the first case, an 



%:==>HERE<==
\on{HERE}


\on{should be a trait}
\begin{code}{}
doesNotUnderstand: aMessage
	| messageName |
	messageName := aMessage selector asString.
	(self class instVarNames includes: messageName)
		ifTrue: [
			self class compile: messageName, String cr, ' ^ ', messageName.
			^ aMessage sendTo: self ].
	super doesNotUnderstand: aMessage
\end{code}



\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{DynamicAccessors}
	\caption{Dynamically creating accessors.\label{fig:DynamicAccessors}}
\end{figure}


%:======================================
\section{Controlling messages}

\on{
- override doesNotUnderstand\\
--- trap msgs sent to an object (with Proxy and with msgNotUnderstood)\\
- anonymous classes (see slides)\\
- method wrappers
}

\on{Using doesNotUnderstand to automatically create accessors for instance variables; package as a reusable trait!}

\on{Object perform:}

\on{Object primitiveChangeClassTo: become: and becomeForward: (see slides with minimal object example)}

%:======================================
\section{Methods as first class entities}

Compared to other reflective programming languages, \pharo is a \st implementation that brings reflection a step further. Whereas it handles \emph{methods as first class entities} that can be modified and replaced on the fly, it also allows for \emph{method execution reification}, exposing dynamic information related to method execution as objects.


\on{
- Methods as Objects; compiled methods; wrappers; spy\\
--- method dictionaries and compiled methods -- compiling, invoking \& removing methods\\
--- method wrappers: coverage; memoization\\
--- coverage checking of a class w. method wrappers\\
--- automatic memoization with method wrappers\\
}

\on{;""Q How do I check which methods of my package are not covered by tests?""
;""A"" Load the *http://www.squeaksource.com/ObjectsAsMethodsWrap.html* SqueakSource project and run:}

\begin{code}{}
category := 'SCGPier'.
w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).

tr := TestRunner new.
ToolBuilder open: tr.
[tr
	categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
	selectAllClasses;
	runAll.]
ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].

((w select: [:each | each executed not ])
	collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
\end{code}


%-------------------------------------------------------------------------
\subsection{Reification of Methods} 

In \pharo, both classes and methods are represented by first class objects that can be accessed and even changed at runtime. 

\emph{Compiled methods} are objects in \pharo that describe the executable part of methods. A compiled method contains a pointer to the source code and the code executed by the virtual machine, the bytecode.

Compiled methods are stored in a method dictionary, in which keys are method names and values corresponding compiled methods. A method dictionary may be accessed from a given class by sending the message \ct{methodDict} to this class. For instance, the expression \ct{ExampleClass methodDict} returns the dictionary of methods for the class \ct{ExampleClass}.

Method dictionaries provide an interface for adding or replacing methods. When a new method is added from a development tool, such as the system browser, in essence, the system adds a new entry in the method dictionary of the class in which the method has been compiled for:

\begin{code}{}
ExampleClass methodDict at: #myMethod put: aCompiledMethod
\end{code}

A compiled method (\ct{aCompiledMethod}) is added to the method dictionary of the class \ct{ExampleClass} under the name \ct{myMethod}. The effect is the addition of a new method.

Having compiled methods as plain objects is a characteristic shared by most \st implementations. As we shall see in the coming section, one particularity of \pharo is to not restrict values contained in a method dictionary to be instances of \ct{CompiledMethod}.

%-------------------------------------------------------------------------
\subsection{Reification of method execution}

When a message named \emph{meth} is sent to an object, the class of receiver looks up the method to use to handle the message. If this class does have a method, it asks its superclass, and so on, up the inheritance chain. Once the method named \emph{meth} found in one of the superclass (\ie its method dictionary contains an entry for \emph{meth}), then the corresponding value associated with \emph{meth} is fetched from the method dictionary by the virtual machine (VM).

Once fetch, this method gets interpreted by the VM. At that stage, one of two cases happens: either this method is a \emph{compiled method} as we have seen previously, or it is a plain object that is not a compiled method. If this value is a compiled method (an instance of the class \ct{CompiledMethod}), then the VM directly interprets the bytecode. If this value is \emph{not} a compiled method, then the VM performs a \emph{reification of the method execution}.

This method execution reification is performed by the VM when sending the message \ct{run: methodName with: listOfArguments in: receiver} to this object method. In such a case, \ct{methodName} contains the name of the method currently invoked, \ct{listOfArguments} contains the list of arguments provided, and \ct{receiver} a reference to the receiver to the message.

For instance, let assume two classes, \ct{C} and \ct{Wrapper}:

\begin{code}{}
Object subclass: #C
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Example'.
 
Object subclass: #Wrapper
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Example'.
\end{code}

The class \ct{Wrapper} contains a method named \ct{run:with:in:} that takes three arguments, a name (\ct{methodName}), an array of objects (\ct{listOfArguments}), and an object reference (\ct{receiver}):

\begin{code}{}
Wrapper>>>run: methodName with: listOfArguments in: receiver
	"We first display some info on the standard output stream"
	Transcript show: 'Method ', methodName,
		' arguments: ', listOfArguments printString,
		' receiver: ', receiver printString.

	"Then we return the first element of the provided list"
	^ listOfArguments first
\end{code}

Prior to returning the first elements of \ct{listOfArguments}, some information is written to the standard output stream.

%The set of methods defined by a class is contained in a method dictionary, which can be accessed by sending the message \ct{methodDict} to a class. 
As we have seen in the previous section, a method \ct{foo:} is added to the class \ct{C} by altering its method dictionary:

\begin{code}{}
"We create an instance of Wrapper"
w := Wrapper new.

"We create an instance of C"
c := C new.

"We add a new method named foo: to C"
C methodDict at: #foo: put: w.
\end{code}

The last line above adds an entry named \ct{foo:} to the method dictionary of \ct{C}. Instances of \ct{C} therefore understand messages named \ct{foo:}. Because of the method execution reification mechanism, evaluating \ct{c foo: 10} is in fact evaluated by the VM as:

\begin{code}{}
w run: #foo: with: #(10) in: c
\end{code}

The result is \ct{10}, and displays the following on the standard output stream:

\begin{code}{}
Method foo: arguments: #(10) receiver: a C
\end{code}

Reification of method execution is an expressive mechanism that enables a whole range of dynamic meta operations. As an example, 

%-----------------------------------------------------------------
\subsection{Example with Spy}

As an illustration of section given above, this section presents \emph{Spy}, a small application that infers relationship between classes at runtime. Spy is available on SqueakSource\footnote{\url{http://www.squeaksource.com/Spy}}. 

A spy is installed on any class, with an \ct{installOn:} method and is removed by sending \ct{removeSpy} to a spied class. Spy is used as follows: 
\begin{itemize}
\item \ct{Spy installOn: aClass} -- installs a spy on a class \ct{aClass};
\item \ct{aClass stat} -- returns a textual description of the interaction of \ct{aClass};
\item \ct{aClass removeSpy} -- removes the spy from the class.
\end{itemize}

The idea is the following: installing spy will replace all compiled method of the class with instance of the class \ct{Spy}. Each instance of these instance knows the compiled method it has replaced. At runtime, each spy evaluates its compiled methods and uses introspection to extract dynamic information.

\ct{Spy} is a subclass of \ct{Object}
\begin{code}{}
Object subclass: #Spy
	instanceVariableNames: 'originalMethod nbOfcalls callingClasses selector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Spy'
\end{code}

Few accessors and an initialization are necessary:
\begin{code}{}
Spy>>>callingClasses
	^ callingClasses ifNil: [callingClasses := OrderedCollection new]

Spy>>>originalMethod
	^ originalMethod

Spy>>>originalMethod: aCompiledMethod
	originalMethod := aCompiledMethod 

Spy>>>initialize
	super initialize.
	nbOfcalls := 0.
\end{code}

The variable \ct{callingClasses} will contains the classes that the spied class interact with. The compiled method the spy will replace is referenced by \ct{originalMethod}.

The main method is \ct{run:with:in:}:
\begin{code}{}
Spy>>>run: methodName with: listOfArguments in: receiver
	| callingClass |
	callingClass := thisContext sender receiver class.
	(self callingClasses includes: callingClass)
		ifFalse: [self callingClasses add: callingClass].
	nbOfcalls := nbOfcalls + 1.
		
	^ originalMethod valueWithReceiver: receiver arguments: listOfArguments 
\end{code}

The pseudo variable \ct{topContext} represents the top frame of the run-time stack. The frame below the top one is the result of \ct{thisContext sender}. The class of the receiver of this frame is obtained by sending the message \ct{receiver} and \ct{class}. This class is then inserted into \ct{callingClasses}. The compiled method is then evaluated on the receiver of the original message (and not the spy!) with the same arguments.

The \pharo interpreter may have to remove all references to this method form its method look cache. The following has to be defined as well:

\begin{code}{}
Spy>>>flushCache
	<primitive: 116>
\end{code}

Note that each object intended to replace a compiled method in a method dictionary has to understand this method.

Each spy is able to generate a little summary:

\begin{code}{}
Spy>>>summary
	^ selector printString, ' has been called: ', nbOfcalls asString, ' by ', self callingClasses asString
\end{code}

The \ct{installOn:} method will replace each compiled method with an instance of \ct{Spy}. Note that this method has to be defined on the class side:

\begin{code}{}
Spy class>>>installOn: aClass
	| dict cm |
	dict := aClass methodDictionary.
	dict keys do:
		[:k|
			cm := dict at: k.
			cm isCompiledMethod 
			 	ifTrue: [dict at: k put: (self new originalMethod: cm; selector: k; yourself)]]
			
\end{code}

The \ct{Spy} class is fully defined. The \ct{Behavior} class needs to be extended with few methods:

\begin{code}{}
Behavior>>>removeSpy
	| v |
	self methodDictionary keys do:
		[:k|
			v := self methodDict at: k. 
			(v class == Spy)
					ifTrue: [self methodDict at: k put: v originalMethod]]

Behavior>>>stat
	| ans |
	ans := ''.
	self methodDict values do: 
		[:spy|
				(spy isKindOf: Spy)
					ifTrue: [ans := ans, spy summary, String cr]].
	^ ans
\end{code}

The Spy application is now fully defined. As an example of usage, a spy may be installed on the class \ct{Stream} with \ct{Spy installOn: Stream}. Then print the result of \ct{Spy stat}. You should have something that looks like:

\begin{code}{}
 '#next:put: has been called: 0 by an OrderedCollection()
...
#basicNextPut: has been called: 71 by an OrderedCollection(Latin1TextConverter)
...
#nextPutAll: has been called: 27 by an OrderedCollection(WriteStream LimitedWriteStream)
...
'
\end{code}

\ct{Stream} may be freed from its spy with \ct{Stream removeSpy}.


%:======================================
\section{Chapter summary}

It is natural to use the reflective features in \st.
Indeed, the whole development environment and its code browsers are built using the introspective interfaces of objects and classes.
We want to stress that it is really interesting to be able to access and modify the objects that represent the program; it makes it unneccessary to devise alternative representations such as abstract syntax trees to build development tools (like Eclipse).
To fix Java~1.0's lack in this respect, Java~1.2 added the ``reflextive'' API ---which is actually only introspective.
Moreover, if the classes and other objects underlying the program execution offer introspective interfaces, then all program representations stay synchronized with the code at all times.
It is thus not needed to keep these representations up-to-date anymore.



%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================



1.1 Introspection
- inspecting objects
- accessing instance variables
- query all instances with given properties
- iterating instance variables
- querying classes; subclasses; methods understood
- browsing code; querying method relationships
- code metrics

1.2 Browsing Code
- SystemNavigation

1.3 Classes, method Dictionaries and methods
- classes, method dictionaries and compiled methods
- inspecting classes

1.4 Browsing Environments
- refactoring browser scoped environments
- code smells

1.5 Accessing the run-time context
- thisContext and Method Contexts
- haltIf:



---

* perform:; valueWithReceiver:
* compile:
* MethodContext


Controlling messages
- trap with Proxy and override doesNotUnderstand (uses become:) ???
- instead use example with object that auto-creates accessors on demand (using a trait?)
- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
- spy (form a method wrapper)
- method wrappers (simplified interface)

Method wrappers
- run:with:in:
- coverage
- memoization
- collect direct senders; class collaborations
- pre and postconditions
Other stuff:
- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)

- PointerFinder?