% $Author$
% $Date$
% $Revision$

% HISTORY: [see also Metaprogramming2.tex]
% 2007-05-22 - Damien Pollet started (translation from French article by ...?)
% 2008-01-15 - Alex added text
% 2008-12-15 - Oscar revised
% 2009-03-24 - Stef started new chapter (acttalk ...)

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6in,9in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Introspecting and metaprogramming}\label{cha:metaprog}

\on{I have interrupted editing this chapter! (in middle of section 1.2)}

\on{Ideas for metaprogramming examples:\\
- pointer finder (who points to me)\\
- listing all iVars\\
- coverage checking of a class w. method wrappers\\
- automatic memoization with method wrappers\\
- trap msgs sent to an object (with Proxy and with msgNotUnderstood)
}

\on{;""Q How do I check which methods of my package are not covered by tests?""
;""A"" Load the *http://www.squeaksource.com/ObjectsAsMethodsWrap.html* SqueakSource project and run:
=category := 'SCGPier'.
=w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
=
=tr := TestRunner new.
=ToolBuilder open: tr.
=[tr
=	categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
=	selectAllClasses;
=	runAll.]
=ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
=
=((w select: [:each | each executed not ])
=	collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
''Actually, the latest TestRunner integrated in Pharo now does this for you.''}

Like all Smalltalk dialects, \squeak is a reflective programming language.
\on{Needs a gentler explanation.}
For a programming language, being reflective means that it supports both \emph{introspection} and \emph{intercession}.
Introspection is the ability to \emph{look} at the data structures that define the language itself, like objects, classes, the execution stack.
Intercession is the ability to \emph{modify} these structures, in other words to change the language semantics and the behavior of a program from within the program itself.

For instance, this lets us add spy methods, or manipulate the execution stack from a debugger.

In this chapter, you will read about uses of introspection that are useful for day-to-day programming.

%=================================================================
\section{Under the hood: instances} % (fold)

Using the inspector, you can look at an object, change the values of its instance variables, and even send messages to it.

\dothis{Evaluate the following code in a workspace:}
\begin{code}{| w |}
w := Workspace new.
w openLabel: 'My Workspace'.
w inspect
\end{code}

This will open a second workspace and an inspector.
The inspector shows the internal state of this new workspace, listing its instance variables in the left part (\ct!dependents!, \ct!contents!, \ct!bindings!...) and the value of the selected instance variable in the right part.
The \ct!contents! instance variable represents whatever the workspace is displaying in its text area, so i you select it, the right part will show an empty string.

\on{I would first type some text in the workspace, accept it and see the inspector change.}


Now type \ct!'1+2'! in place of that empty string, then \emph{accept} it.
The value of the \ct!contents! variable changed, but the workspace window didn't notice it, so it didn't redisplay itself.
To trigger the window refresh, evaluate \ct!self contentsChanged! in the lower part of the inspector. \damien{the french version says that the refresh didn't happen because \ct!contents:! doesn't trigger it, but the inspector bypasses the accessor...}
\on{Then we should also have an example where we send \ct{self contents: 'yahoo'}}

%-----------------------------------------------------------------
\subsection{Accessing instance variables}

How does the inspector work?
In Smalltalk, all instance variables are protected.
In theory, it is impossible to access them if the class doesn't define any accessor.
In practice, the inspector can access instance variables without needing accessors, because it uses the reflective abilities of \st.
In \st, classes define instance variables either by name or by numeric indexes.
The inspector uses methods defined by the \ct!Object! class to access them: \lct{instVarAt: \emph{index}} and \lct{instVarNamed: \emph{aString}} can be used to get the value of the instance variable at position \lct{\emph{index}} or identified by \lct{\emph{aString}}, respectively; to assign new values to these instance variables, it uses \ct!instVarAt:put:! and \ct!instVarNamed:put:!.

For instance, you can change the value of the \ct!w! instance variable of the first workspace with: \ct!w instVarNamed: 'contents' put: '3+4'; contentsChanged!.

Please note that these methods are useful to build development or debugging tools, but using them to develop conventional applications is a bad idea: these reflective methods break the encapsulation principles of object-oriented programming.

Both \ct!instVarAt:! and \ct!instVarAt:put:! are primitive methods, meaning that they invoke a primitive operation of the \squeak virtual machine.
If you consult the code of these methods, you will see the special syntax \ct!<primitive: xx>! where \ct!xx! is an integer.

\needlines{5}
\begin{code}{}
Object>>>instVarAt: index 
	"Primitive. Answer a fixed variable in an object. ..."
	!\textbf{<primitive: 73>}!
	"Access beyond fixed variables."
	^self basicAt: index - self class instSize		
\end{code}

Typically, the code after the primitive invocation is not executed.
It is executed only when the primitive fails. In this specific case, if we try to access a variable that does not exist, then the code following the primitive will be tried.
This also allows the debugger to be started on primitive methods.
Although it is possible to modify the code of primitive methods, beware that this is a quite risky business for the stability of your \squeak system.

There is a limited number of primitive operations in \squeak. They constitute the basic actions in \st: basic operations on integers, accessing input/output peripherals (disk, screen, network...).
Some of these primitives also accelerate system functions.
It is also possible to define custom primitives and to link them to plugins written in C to benefit from external libraries or from the speed of a native implementation.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{allInstanceVariables}
	\caption{Displaying all instance variables of a \ct!SystemWindow!.\label{fig:allInstanceVariables}}
\end{figure}

\figref{allInstanceVariables} shows how to display in a \ct!Transcript! the contents of the instance variables of an arbitrary instance (\ct!someInstance!) of class \ct!SystemWindow!.
The method \ct!allInstVarNames! returns all the names of the instance variables of a given class.

In the same spirit, it is possible to gather instances that have specific properties.
For instance, to get all instances of class \ct!Browser! whose instance variable \ct!systemOrganizer! is not \ct!nil!, try this expression:
\begin{code}{}
Browser allInstances select: [:c | (c instVarNamed: 'systemOrganizer') notNil]
\end{code}

%-----------------------------------------------------------------
\subsection{Iterating over instance variables}

Let us consider the message \ct!instanceVariableValues!, which returns a collection of all values of instance variables defined by this class, excluding the inherited instance variables.
For instance:
\begin{code}{@TEST}
(1@2) instanceVariableValues --> an OrderedCollection(1 2)
\end{code}

The method is implemented in \ct{Object} as follows:
\needlines{9}
\begin{code}{}
Object>>>instanceVariableValues
	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class."	
	| c |
	c := OrderedCollection new.
	self class superclass instSize + 1
		to: self class instSize
		do: [ :i | c add: (self instVarAt: i)].
	^ c
\end{code}

% This example shows how useful it is to be able to access instance variables via their position \alex{maybe?: this example shows how index-based variable access is useful}
This method iterates over the indexes of instance variables that the class defines, starting just after the last index used by the superclasses.
(The method \ct!instSize! returns the number of all named instance variables that a class defines.)

%-----------------------------------------------------------------
\subsection{Querying classes and interfaces}

The development tools in \squeak (code browser, debugger, inspector...) all use the reflective features we have seen so far.

Here are a few other messages that might be useful to build development tools:


\lct{isKindOf: \emph{aClass}} returns true if the receiver is instance of \lct{\emph{aClass}} or of one of its superclasses.

For instance:
\begin{code}{@TEST}
1.5 class                     --> Float
1.5 isKindOf: Number --> true
1.5 isKindOf: Integer   --> false
\end{code}


\lct{respondsTo: \emph{aSymbol}} returns true if the receiver has a method whose selector is \lct{\emph{aSymbol}}.

For instance:
\begin{code}{@TEST}
1.5 respondsTo: #floor      --> true    "since Number implements floor"
1.5 floor                            --> 1
Exception respondsTo: #, --> true    "exception classes can be grouped"
\end{code}

Please note that these features are especially useful for defining development tools, but are normally not appropriate for typical applications.
Asking an object for its class, or querying it to discover which messages it understands, are typical signs of design problems, since they violate the principle of encapsulation.
Development tools, however, are not normal applications, since their domain is that of software itself. As such these tools have a right to dig deep into the internal details of code.

%Once again, the reflective features of \squeak are only useful to define development tools, and it is risky to use them to develop applications.
%Indeed, using the type of an object to drive execution of a method or another often reveals a design problem.

%\st offers other introspection possibilities for methods or the execution stack, the process scheduler, the memory manager... but we can't detail everything here; try to read the code and experiment by yourselves.

There also exist mechanisms for introspecting on various parts of the run-time system, such as compiled methods, the execution stack, the process scheduler, the memory manager and so on. For now we will focus on navigating through objects and classes, and we will look more closely at the runtime system in an other chapter.
\on{to be planned ...}

% section under_the_hood_instances (end)

%=================================================================
\section{Browsing code} % (fold)

In \st, classes are normal objects, and they provide interesting features to navigate over their instances.
Most of the messages we will look at now are implemented in \ct{Behavior}, so they are understood by all classes.

As we saw previously, you can obtain an instance of a given class by sending it the message \ct!#someInstance!.

\begin{code}{} % Cannot test this
ByteString someInstance --> 'collection'
\end{code}

You can also gather all the instances with \ct!#allInstances!, or the number of alive instances in memory with \ct!#instanceCount!.

\begin{code}{} % Cannot test this
ByteString allInstances     --> #('collection' 'position'  ...)
ByteString instanceCount --> 104565
\end{code}

These features can be very useful when debugging an application, because you can ask a class to enumerate those of its methods that have specific properties.
\begin{itemize}
\item \ct!whichSelectorsAccess:! returns the list of all selectors of methods that read the instance variable named as the argument
\item \ct!whichSelectorsStoreInto:! returns the selectors of methods that modify the value of an instance variable
\item \ct!whichSelectorsReferTo:! returns the selectors of methods that send a given message
\item \ct!crossReference! associates each message with the set of methods that send it.
\end{itemize}

%\ct!an IdentitySet(#rotateBy:about: #translateBy: #isInsideCircle:with:with: #sideOf: #nearestPointAlongLineFrom:to: #normalized #eightNeighbors #dist: #hash #rotateBy:centerAt: #theta #grid: #fourNeighbors #dotProduct: #scaleFrom:to: #normal #onLineFrom:to:within: #+ #degrees #interpolateTo:at:)!.

\begin{code}{} % TOO FRAGILE TO TEST
Point whichSelectorsAccess: 'x'    --> an IdentitySet(#'\\' #= #scaleBy: ...)
Point whichSelectorsStoreInto: 'x' --> an IdentitySet(#setX:setY: ...)
Point whichSelectorsReferTo: #+  --> an IdentitySet(#rotateBy:about: ...)
Point crossReference --> an Array(
		an Array('*' an IdentitySet(#rotateBy:about: ...))
		an Array('+' an IdentitySet(#rotateBy:about: ...))
		...)
\end{code}

The following messages take inheritance into account:
\begin{itemize}
\item \ct{whichClassIncludesSelector:} returns the superclass that implements the given message
\item \ct{unreferencedInstanceVariables} returns the list of instance variables that are neither used in the receiver class nor any of its subclasses
\end{itemize}

\begin{code}{@TEST}
Rectangle whichClassIncludesSelector: #inspect --> Object
Rectangle unreferencedInstanceVariables            --> #()
\end{code}

\ct{SystemNavigation} is a facade that supports various useful methods for querying and browsing the source code of the system.
\ct!SystemNavigation default! returns an instance you can use to navigate the system.
For example:

\begin{code}{@TEST}
SystemNavigation default allClassesImplementing: #ifTrue: --> {Boolean. True. False}
\end{code}

%\ct!SystemNavigation default allClassesImplementing: #+! returns all classes that implement the message \ct!#+!.
%	In this case we get \ct!an Array(Number Fraction Float Integer SmallInteger LargePositiveInteger ScaledDecimal DateAndTime Duration Timespan Player Color Collection WordArray FloatArray KedamaFloatArray String Interval AbstractSound MixedSound Point Voice Complex TraitDescription TraitComposition TraitTransformation TComposingDescription)!.
%	As you can see, it is possible to add integers, fractions, strings or intervals.

The following messages should also be self-explanatory:

\begin{code}{}
SystemNavigation default allSentMessages size          --> 24930
SystemNavigation default allUnsentMessages size      --> 6431
SystemNavigation default allUnimplementedCalls size --> 270
\end{code}

Note that messages implemented but not sent are not necessarily useless, since they may be sent implicitly (\eg, using \ct{perform:}).
Messages sent but not implemented, however, are more problematic, because the methods sending these messages will fail at runtime.
They may be a sign of unfinished implementation, obsolete APIs, or missing libraries.





%:ON IS HERE <====
\on{I am here now}


\ct!SystemNavigation default allCallsOn: #Point! returns all messages sent explicitly to \ct!Point! as a receiver.



All these features are integrated in the programming environment of \squeak, in particular in the code browsers.
As shown in \secref{cha:env}, you can list all methods that have the same name (implementors) or all methods that send a message (senders).
This is quite handy: for instance, when you want to change the name of a method, to check that you didn't miss one message send that could invoke this method (\figref{implementors}). \damien{is "invoke a method" OK here?}

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{implementors}
	\caption{Displaying all classes that implement \ct!\#+!.\label{fig:implementors}}
\end{figure}

To see the internal structure of a class, you can inspect it like any object.
In \figref{CompiledMethod}, the inspector at the back shows the structure of class \ct!Point!.
You can see that the class stores its methods in a dictionary, indexing them by their selector.
The frontmost inspector shows the decompiled bytecode of \ct!Point!'s method \ct!#*!.

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{CompiledMethod}
	\caption{Inspecting class \ct!Point! and the bytecode of its \ct!\#*! method.\label{fig:CompiledMethod}}
	\on{re-do with white background!}
\end{figure}

\st is really a completely open and transparent system, where all the code is available for reading.
You can study the whole system as you wish, because there is no hidden code.
The primitive part of the system, \ie which is not written in \st, is reduced to its simplest expression.
Among \st dialects, \squeak has the peculiarity that even its virtual machine is written in \st, so it is possible to run and debug it inside a \squeak image!
Though this actually works, it is quite slow, and for actual use the virtual machine is translated to C and compiled to a native executable.

% section browsing_the_code (end)

%=================================================================
\section{Practical uses for introspection} % (fold)

%-----------------------------------------------------------------
\subsection{Code metrics}

Let's see how we can use \st's introspection features to quickly define code metrics.
A code metric is a measure of program code like depth in the inheritance hierarchy, the number of direct or indeirect subclasses, the number of methods or of instance variables in each class, or the number of locally defined methods or instance variables.
When discovering the code of a new application, you can evaluate a metric to get a rough idea of what the code looks like.
\scrref{metrics} computes a few code metrics for Morphic; these numbers can vary depending on the image you are using.
Results for class \ct!Morph!, which is the superclass of all graphical objects in \squeak, reveal that it is a huge class, and that it is at the root of a huge hierarchy. Maybe it needs some refactoring!

\begin{script}[metrics]{A few code metrics}
	inheritanceDepth := Morph allSuperclasses size. "2"
	methods := Morph allSelectors size. "1593"
	instVars := Morph allInstVarNames size. "6"
	addedMethods := Morph selectors size. "1165"
	addedInstVars := Morph instVarNames size. "6"
	directSubclasses := Morph subclasses size. "45"
	totalSubclasses := Morph allSubclasses size. "412"
\end{script}

One of the most interesting metrics in the domain of object-oriented languages is the number of methods that extend methods inherited from the superclass.
This informs us about the relation between the class and its superclasses.

Here is a script that identifies methods in class \ct!Browser! that call the method they redefine, like this:
\begin{code}{}
Browser >>> xx
	"..."
	super xx
\end{code}

\begin{script}[browsersendstosuper]{Methods of \ct!Browser! redefining via \ct!super!}
Browser selectors select: [ :eachSelector |
	| method |
	method := Browser compiledMethodAt: eachSelector.
	method sendsToSuper ]
\end{script}

In this code, we ask to class \ct!Browser! all messages it understands (\ct!selectors!) then select those whose associated method makes a call to the superclass.
This returns a collection of methods, containing for instance \ct!#veryDeepInner!.
You can see that the \st bytecode itself is viewed as an object that we can query for information.
We could even imagine methods that transform this bytecode.

%-----------------------------------------------------------------
\subsection{Detecting possible errors}

Sending a message to \ct!super! is a bad idea when that message is different from the one the current method implements.
This practice often causes bugs when adding subclasses, so good developers avoids that pattern of code.
It's easy to automatically identify occurences of this pattern: we simply have to find methods that make super-sends with a different selector than their own.

\begin{script}[findSuperSends]{Identifying bad super-sends}
Collection selectors select: [ :eachSelector |
	| method |
	method := Collection compiledMethodAt: eachSelector.
	method sendsToSuper and: [(method messages includes: eachSelector) not]]
\end{script}

Note that this script doesn't find everything we want... it doesn't detect methods containing loops or recursion like the following:
\begin{code}{}
xxx
	super yyy. "send something else than xxx to super"
	self zzz
\end{code}

When executing \scrref{findSuperSends} on class \ct!Collection!, you should obtain method \ct!printNameOn:! which does send \ct!printOn:! to \super:
\begin{method}[printNameOn]{A method that sends a different message to super}
Collection>>>printNameOn: aStream
	super printOn: aStream
\end{method}

In fact this method is used by \ct!printOn:! (\mthref{oldPrintOn}), which could be refactored as in \mthref{newPrintOn}.

\begin{method}[oldPrintOn]{The sender of \lct{\#printNameOn:}}
Collection>>>printOn: aStream
	"Append a sequence of characters that identify the receiver to aStream."
	self printNameOn: aStream.
	self printElementsOn: aStream
\end{method}

\begin{method}[newPrintOn]{New version of \mthref{oldPrintOn}, after inlining the \lct{\#printNameOn:} super-send}
Collection>>>printOn: aStream
	"Append a sequence of characters that identify the receiver to aStream."
	super printOn: aStream.
	self printElementsOn: aStream
\end{method}

Now \ct!#printNameOn:! (\mthref{printNameOn}) is not needed anymore. Well, in this case... is it used in other classes? Let's ask \squeak:
\begin{example}[sendersofprintnameon]{Asking for the senders of \lct{\#printNameOn:}}{}
SystemNavigator default allCallsOn: #printNameOn:
--> an OrderedCollection(A MethodReference RunArray >> printOn: aMethodReference Bitmap >> printOn: aMethodReference Text >> printOn: aMethodReference CompiledMethod >> printOn:)
\end{example}

So we should also refactor classes \clsind{RunArray}, \clsind{BitMap}, \clsind{Text}, and \clsind{CompiledMethod} that are sending message \ct!#printNameOn:!.

%-----------------------------------------------------------------
\subsection{Intelligent breakpoints}

In the 3.8 version of \squeak introduced a new kind of breakpoints.
Those are quite useful and are implemented by the \ct!Object>>>haltIf:! method.
This breakpoint only halts program execution if the method it's placed in was called by the one whose name was passed as an argument.
This is very useful to halt a method only during the execution of a test and not every time it is called.
For instance, the expression \ct!self haltIf: #testFoo! will only halt execution of its containing method if this method was called, directly or indirectly, from \ct!testFoo!.
The definition of \ct!haltIf:! is quite simple and fits in five lines; it uses the pseudo-variable \ct!thisContext!, which refers to the execution stack, represented as an object (\ct!thisContext! is one of the six keywords in Smalltalk, with \self, \super, \nil, \ct!true!, and \ct!false!).

\begin{method}[objecthaltif]{Implementation of a conditional breakpoint}
Object>>>haltIf: condition
	"This is the typical message to use for inserting breakpoints during debugging. Param can be a block or expression, halt if true.
	If the condition is a selector, we look up in the callchain. Halt if any method's selector equals selector."
	| cntxt |
	cntxt := thisContext.
	[cntxt sender isNil] whileFalse: [
		cntxt := cntxt sender.
		(cntxt selector = condition) ifTrue: [Halt signal]].
	^self.
\end{method}

Starting from \ct!thisContext!, \ct!haltIf:! goes up through the execution stack, checking if the name of the calling method is the same as the one passed as parameter.
If this is the case, then it raises an exception which, by default, summons the debugger.
This example shows the power of Smalltalk, which allows to define powerful features and tools from within the language itself.

The pseudo-variable \ct!thisContext! is especially used in the \squeak debugger.
It contains an instance of the \clsind{MethodContext} class.
This instance contains information about the method that is being executed, the stack pointer (\ct!stackpc!), and the program pointer (\ct!pc!).

In the following example, we halted \squeak's evaluation loop by pressing \short{.} and inspecting the current context.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{MethodContext}
	\caption{Inspecting the execution context of the evaluation loop in \squeak.\label{fig:MethodContext}}
\end{figure}

Via \ct!thisContext!, the Seaside web framework also accesses the execution stack, but it modifies it on the fly to easily implement reusable components over HTTP.

% section practical_uses_for_introspection (end)

%:======================================
\section{Methods as first class entities}

Compared to other reflective programming languages, \squeak is a Smalltalk implementation that brings reflection a step further. Whereas it handles \emph{methods as first class entities} that can be modified and replaced on the fly, it also allows for \emph{method execution reification}, exposing dynamic information related to method execution as objects.


%-------------------------------------------------------------------------
\subsection{Reification of Methods} 

In Squeak, both classes and methods are represented by first class objects that can be accessed and even changed at runtime. 

\emph{Compiled methods} are objects in Squeak that describe the executable part of methods. A compiled method contains a pointer to the source code and the code executed by the virtual machine, the bytecode.

Compiled methods are stored in a method dictionary, in which keys are method names and values corresponding compiled methods. A method dictionary may be accessed from a given class by sending the message \ct{methodDict} to this class. For instance, the expression \ct{ExampleClass methodDict} returns the dictionary of methods for the class \ct{ExampleClass}.

Method dictionaries provide an interface for adding or replacing methods. When a new method is added from a development tool, such as the system browser, in essence, the system adds a new entry in the method dictionary of the class in which the method has been compiled for:

\begin{code}{}
ExampleClass methodDict at: #myMethod put: aCompiledMethod
\end{code}

A compiled method (\ct{aCompiledMethod}) is added to the method dictionary of the class \ct{ExampleClass} under the name \ct{myMethod}. The effect is the addition of a new method.

Having compiled methods as plain objects is a characteristic shared by most Smalltalk implementations. As we shall see in the coming section, one particularity of Squeak is to not restrict values contained in a method dictionary to be instances of \ct{CompiledMethod}.

%-------------------------------------------------------------------------
\subsection{Reification of method execution}

When a message named \emph{meth} is sent to an object, the class of receiver looks up the method to use to handle the message. If this class does have a method, it asks its superclass, and so on, up the inheritance chain. Once the method named \emph{meth} found in one of the superclass (\ie its method dictionary contains an entry for \emph{meth}), then the corresponding value associated with \emph{meth} is fetched from the method dictionary by the virtual machine (VM).

Once fetch, this method gets interpreted by the VM. At that stage, one of two cases happens: either this method is a \emph{compiled method} as we have seen previously, or it is a plain object that is not a compiled method. If this value is a compiled method (an instance of the class \ct{CompiledMethod}), then the VM directly interprets the bytecode. If this value is \emph{not} a compiled method, then the VM performs a \emph{reification of the method execution}.

This method execution reification is performed by the VM when sending the message \ct{run: methodName with: listOfArguments in: receiver} to this object method. In such a case, \ct{methodName} contains the name of the method currently invoked, \ct{listOfArguments} contains the list of arguments provided, and \ct{receiver} a reference to the receiver to the message.

For instance, let assume two classes, \ct{C} and \ct{Wrapper}:

\begin{code}{}
Object subclass: #C
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Example'.
 
Object subclass: #Wrapper
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Example'.
\end{code}

The class \ct{Wrapper} contains a method named \ct{run:with:in:} that takes three arguments, a name (\ct{methodName}), an array of objects (\ct{listOfArguments}), and an object reference (\ct{receiver}):

\begin{code}{}
Wrapper>>>run: methodName with: listOfArguments in: receiver
	"We first display some info on the standard output stream"
	Transcript show: 'Method ', methodName,
		' arguments: ', listOfArguments printString,
		' receiver: ', receiver printString.

	"Then we return the first element of the provided list"
	^ listOfArguments first
\end{code}

Prior to returning the first elements of \ct{listOfArguments}, some information is written to the standard output stream.

%The set of methods defined by a class is contained in a method dictionary, which can be accessed by sending the message \ct{methodDict} to a class. 
As we have seen in the previous section, a method \ct{foo:} is added to the class \ct{C} by altering its method dictionary:

\begin{code}{}
"We create an instance of Wrapper"
w := Wrapper new.

"We create an instance of C"
c := C new.

"We add a new method named foo: to C"
C methodDict at: #foo: put: w.
\end{code}

The last line above adds an entry named \ct{foo:} to the method dictionary of \ct{C}. Instances of \ct{C} therefore understand messages named \ct{foo:}. Because of the method execution reification mechanism, evaluating \ct{c foo: 10} is in fact evaluated by the VM as:

\begin{code}{}
w run: #foo: with: #(10) in: c
\end{code}

The result is \ct{10}, and displays the following on the standard output stream:

\begin{code}{}
Method foo: arguments: #(10) receiver: a C
\end{code}

Reification of method execution is an expressive mechanism that enables a whole range of dynamic meta operations. As an example, 

%-----------------------------------------------------------------
\subsection{Example with Spy}

As an illustration of section given above, this section presents \emph{Spy}, a small application that infers relationship between classes at runtime. Spy is available on SqueakSource\footnote{\url{http://www.squeaksource.com/Spy}}. 

A spy is installed on any class, with an \ct{installOn:} method and is removed by sending \ct{removeSpy} to a spied class. Spy is used as follows: 
\begin{itemize}
\item \ct{Spy installOn: aClass} -- installs a spy on a class \ct{aClass};
\item \ct{aClass stat} -- returns a textual description of the interaction of \ct{aClass};
\item \ct{aClass removeSpy} -- removes the spy from the class.
\end{itemize}

The idea is the following: installing spy will replace all compiled method of the class with instance of the class \ct{Spy}. Each instance of these instance knows the compiled method it has replaced. At runtime, each spy evaluates its compiled methods and uses introspection to extract dynamic information.

\ct{Spy} is a subclass of \ct{Object}
\begin{code}{}
Object subclass: #Spy
	instanceVariableNames: 'originalMethod nbOfcalls callingClasses selector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Spy'
\end{code}

Few accessors and an initialization are necessary:
\begin{code}{}
Spy>>>callingClasses
	^ callingClasses ifNil: [callingClasses := OrderedCollection new]

Spy>>>originalMethod
	^ originalMethod

Spy>>>originalMethod: aCompiledMethod
	originalMethod := aCompiledMethod 

Spy>>>initialize
	super initialize.
	nbOfcalls := 0.
\end{code}

The variable \ct{callingClasses} will contains the classes that the spied class interact with. The compiled method the spy will replace is referenced by \ct{originalMethod}.

The main method is \ct{run:with:in:}:
\begin{code}{}
Spy>>>run: methodName with: listOfArguments in: receiver
	| callingClass |
	callingClass := thisContext sender receiver class.
	(self callingClasses includes: callingClass)
		ifFalse: [self callingClasses add: callingClass].
	nbOfcalls := nbOfcalls + 1.
		
	^ originalMethod valueWithReceiver: receiver arguments: listOfArguments 
\end{code}

The pseudo variable \ct{topContext} represents the top frame of the run-time stack. The frame below the top one is the result of \ct{thisContext sender}. The class of the receiver of this frame is obtained by sending the message \ct{receiver} and \ct{class}. This class is then inserted into \ct{callingClasses}. The compiled method is then evaluated on the receiver of the original message (and not the spy!) with the same arguments.

The Squeak interpreter may have to remove all references to this method form its method look cache. The following has to be defined as well:

\begin{code}{}
Spy>>>flushCache
	<primitive: 116>
\end{code}

Note that each object intended to replace a compiled method in a method dictionary has to understand this method.

Each spy is able to generate a little summary:

\begin{code}{}
Spy>>>summary
	^ selector printString, ' has been called: ', nbOfcalls asString, ' by ', self callingClasses asString
\end{code}

The \ct{installOn:} method will replace each compiled method with an instance of \ct{Spy}. Note that this method has to be defined on the class side:

\begin{code}{}
Spy class>>>installOn: aClass
	| dict cm |
	dict := aClass methodDictionary.
	dict keys do:
		[:k|
			cm := dict at: k.
			cm isCompiledMethod 
			 	ifTrue: [dict at: k put: (self new originalMethod: cm; selector: k; yourself)]]
			
\end{code}

The \ct{Spy} class is fully defined. The \ct{Behavior} class needs to be extended with few methods:

\begin{code}{}
Behavior>>>removeSpy
	| v |
	self methodDictionary keys do:
		[:k|
			v := self methodDict at: k. 
			(v class == Spy)
					ifTrue: [self methodDict at: k put: v originalMethod]]

Behavior>>>stat
	| ans |
	ans := ''.
	self methodDict values do: 
		[:spy|
				(spy isKindOf: Spy)
					ifTrue: [ans := ans, spy summary, String cr]].
	^ ans
\end{code}

The Spy application is now fully defined. As an example of usage, a spy may be installed on the class \ct{Stream} with \ct{Spy installOn: Stream}. Then print the result of \ct{Spy stat}. You should have something that looks like:

\begin{code}{}
 '#next:put: has been called: 0 by an OrderedCollection()
...
#basicNextPut: has been called: 71 by an OrderedCollection(Latin1TextConverter)
...
#nextPutAll: has been called: 27 by an OrderedCollection(WriteStream LimitedWriteStream)
...
'
\end{code}

\ct{Stream} may be freed from its spy with \ct{Stream removeSpy}.
%:======================================
\section{Chapter summary}

It is natural to use the reflective features in Smalltalk.
Indeed, the whole development environment and its code browsers are built using the introspective interfaces of objects and classes.
We want to stress that it is really interesting to be able to access and modify the objects that represent the program; it makes it unneccessary to devise alternative representations such as abstract syntax trees to build development tools (like Eclipse).
To fix Java~1.0's lack in this respect, Java~1.2 added the ``reflextive'' API ---which is actually only introspective.
Moreover, if the classes and other objects underlying the program execution offer introspective interfaces, then all program representations stay synchronized with the code at all times.
It is thus not needed to keep these representations up-to-date anymore.



%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------
\subsection{XXX}
