% $Author: ducasse $
% $Date: 2009-08-24 10:17:33 +0200 (Mon, 24 Aug 2009) $
% $Revision: 28563 $

% HISTORY:
% 2010-02-19 - Stef started

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{The Settings Framework}

When an application gets mature we often needs to provide variations such as the default selection color, the default font and the default font size... Often such variations represent user preferences of possible software customizations. 
Since the 1.1 release, Pharo contains and uses the Settings framework to manage its preferences. However Settings is not limited to manage Pharo preferences but can be used by any applications. The nice thing about Settings is that it is 
not intrusive, it supports a modular decomposition of software and can be added to an application after its inception. 
This is what we will see now.

\section{Settings in a nutshell}
A preference is a particular \emph{value} which is usually accessible from everywhere. Basically such a preference value is stored in a class variable or in an instance variable of a singleton and is directly managed through the use of simple accessors. Pharo contains numerous preferences. As examples, the user interface theme, the desktop background color or a boolean flag to allow or prohibit the use of sound are currently declared as preferences. Although this is not really the subject of this chapter, the point of programming a preferences is covered by section~\ref{sec:ProgrammingAPreference}. 

Pharo users need to browse existing preferences and eventually change their value, this is the major role of the settings browser presented in section~\ref{sec:TheSettingsBrowser}.

A setting is a \emph{declaration} (description) of a preference value. To be viewed and updated through the setting browser, a preference value must be described by a setting. Such a setting is built by a particular method tagged with a pragma. The section~\ref{sec:DeclaringASetting} explains how to declare a setting.

Depending on where and when you are using Pharo, some preferences can change often. As an example, when you are doing a demonstration, you may want to have bigger fonts, at work you may need to set a proxy whereas at home none is needed. Having to change a set of preferences depending on where you are and what you are doing can be very tedious and boring. With the setting browser it is possible to save the current set of preference values in a named style that can be reloaded later. Setting style management is presented in Section~\ref{sec:SettingStylesManagement}.

\section{The Setting browser}
\label{sec:TheSettingsBrowser}
The setting browser, shown in figure~\figref{fig:TheSettingsBrowser}, mainly allows the browsing of all currently declared settings and to change related preference values. To open it, just use the World menu (\menu{World \go System \go Settings}) or evaluate the following expression:
\begin{code}{}
SettingBrowser open
\end{code}
The settings are presented in several trees in the middle panel. Setting searching and filtering is available from the top toolbar whereas the bottom panels show currently selected setting description (left bottom panel) and current package set (right bottom panel). 
\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.3]{SettingBrowser}
\caption{The settings browser}
\figlabel{fig:TheSettingsBrowser}
\end{center}
\end{figure}

\subsection{Browsing and changing preference values}
Setting declarations are organized in trees which can be browsed in the middle panel. In order to get a description for a setting, just click on it: the setting is selected and the left bottom panel is updated with informations about the selected setting. 

Changing a preference value is simply done through the browser: each line holds a widget on the right with which you can update the value. The kind of widget depends on the actual type of the preference value. Whereas a preference value can be of any kind, the setting browser is currently able to present an input widget for the following types: \textit{Boolean}, \textit{Color}, \textit{FilePath}, \textit{FileDirectory}, \textit{Font}, \textit{Number}, \textit{Point} and \textit{String}. A drop-list, a password field or a range input widget using a slider can also be used. Of course, the list of possible widgets is not closed as it is possible to make the setting browser support new kind of preference values or use different input widgets. This point is explained in section~\ref{sec:ExtendingTheSettingsBrowser}.

If the actual type of a setting is either \textit{String}, \textit{FilePath}, \textit{FileDirectory}, \textit{Number} or \textit{Point}, in order to change a value, the user has to enter some text in a editable drop-list widget. In such a case, the input must be confirmed by hinting the return key (or with cmd-s). If such a setting value is changed often, the drop-list widget is very handy because you can retrieve and use previously entered values in one click !

Other possible actions are all acessible from the contextual menu.
Depending on the selected setting, it may be different. Three versions of it are shown in figure \figref{fig:TheSettingsBrowserPopupMenu}.
\begin{figure}[tbh]
\begin{center}
\begin{tabular}{ccc}
\includegraphics[scale=0.5]{popup0.png} & 
	\includegraphics[scale=0.5]{popup1.png} & 
	\includegraphics[scale=0.5]{popup2.png} \\ 
\end{tabular} 
\caption{The contextual popup menu}
\figlabel{fig:TheSettingsBrowserPopupMenu}
\end{center}
\end{figure}
\begin{itemize}
\item \textbf{Browse (b)}: opens a system browser on the method which declares the setting. It is also accessible via the keyboard shortcut \textit{cmd-b} or if you double-click on a setting. It is very handy if you want to change the setting implementation or simply see how it is implemented in order to understand the framework by investigating some examples (how to declare a setting is explained in section~\ref{sec:DeclaringASetting}).
\item \textbf{Set to default (d)}: set the selected setting value to the default one. It is very handy if, as an example, you have played with a setting to observe its effect and finally decide to come back to its default. It is also possible to set to default all settings is one single action, this is explained is section \ref{sec:SettingStylesManagement}.
\item \textbf{Empty list (e)}: If the input widget is an editable drop-list, this menu item allows to forget previously entered values by emptying the recorded list.
\end{itemize}

\subsection{Searching and filtering settings}
Pharo contains a lot of settings and finding one of them can be tedious. 
You can filter the settings list by entering something in the search text field of the top bar of the SettingsBrowser. Then, only the settings which name or description contains the text you've entered will be shown. The text can be a regular expression if the "Regexp" checkbox is checked.

Another way to filter the list of settings is to choose them by package. Just click on the "Choose package" button, then a dialog is opened with the list of packages in which some settings are declared. If you choose one or several of them, then, only settings which are declared in the selected packages will be shown. Notice that the bottom right text pane is updated with the name of the selected packages.


\section{Declaring a setting}
\label{sec:DeclaringASetting}
All global preferences of Pharo can be viewed or changed from the \textit{SettingBrowser}. A preference is typically a class variable or an instance variable of a singleton. If one want to be able to change its value from the \textit{SettingsBrowser}, then a setting must be declared for it.
A setting is declared by a particular class method which must be coded as follow: it takes a builder as argument and it is tagged by the \textit{<systemsettings>} simple pragma. 
%As an example: 
%\begin{code}{}
%AClassInMyPackage class>>settingOn: aBuilder
%  <systemSettings>
%  (aBuilder group: #MySettings)
%    label:'My settings' ...
%\end{code}
The argument \textit{aBuilder} serves as a facade for setting declarations building and the pragma allows the \textit{SettingBrowser} to dynamically discover current setting declarations.

The important point is that a setting declaration must be package specific. It means that each package is responsible for the declaring of its own settings. For a particular package, specific settings are declared by one or several of its classes. The direct benefit is that when the package is loaded, then its settings are automatically loaded and that when a package is unloaded, then its settings are automatically unloaded. 

\subsection{A simple setting}
Let's take the example of the \textit{caseSensitiveFinds} preference. It is a boolean preference which is used for text searching. If it is \textit{true}, then a text finding is case sensitive. This preference is stored in the \textit{CaseSensitiveFinds} class variable in \textit{ParagraphEditor}. Its value can be queried and changed by, respectively, \textit{ParagraphEditor class>>caseSensitiveFinds} and \textit{ParagraphEditor class>>caseSensitiveFinds:} given below:
\begin{code}{}
ParagraphEditor class>>caseSensitiveFinds
	^ CaseSensitiveFinds ifNil: [CaseSensitiveFinds := false]

ParagraphEditor class>>caseSensitiveFinds: aBoolean
	CaseSensitiveFinds := aBoolean
\end{code}

In order to be able to change the \textit{CaseSensitiveFinds} class variable from the settings browser, the method below can be implemented. The result is shown in the screenshot of the \figref{fig:caseSensitiveFinds1}. 

\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
	<systemsettings>
	(aBuilder setting: #caseSensitiveFinds) 
		target: ParagraphEditor;
		label: 'Case sensitive search' translated;
		description: 'If true, then the "find" command in text will always make its searches in a case-sensitive fashion' translated;
		parent: #codeEditing.
\end{code}

\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.4]{caseSensitiveFinds_setting_declaration1}
\caption{First version of the \textit{caseSensitiveFinds} setting}
\figlabel{fig:caseSensitiveFinds1}
\end{center}
\end{figure}

Now, let's study this setting declaration with more details. 

\subsubsection{The header}
\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
...
\end{code}
This class method is declared in CodeHolderSystemSettings. This class is dedicated to settings and contains nothing but settings declarations. But this is not mandatory, in fact any class can have settings declarations. 

This method takes a builder as argument. This object serves as a facade for settings buildings: the contents of the method essentially consists in sending messages to the builder in order to declare and organize a sub-tree of settings.

\subsubsection{The pragma}
A setting declaration is tagged with the \textit{systemsettings} pragma.
\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
	<systemsettings>
...
\end{code}
In fact, when the settings browser is opened, it first collects all settings declarations by searching all methods with the \textit{<systemsettings>} pragma. More, if you compile a setting declaration method while a settings browser is opened then it is automatically updated with the new setting. 

\subsubsection{The setting building}
A setting is simply declared by sending the message \textit{setting:} to the builder with an identifier passed as argument:
\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
	<systemsettings>
	(aBuilder setting: #caseSensitiveFinds) 
...
\end{code}
By default, the identifier passed as argument is considered as the selector which can be used by the settings browser in order to get the preference value and the selector for changing the preference value is by default built by adding a colon to the getter selector. 

These selectors are sent to a target which is by default the class in which the method is implemented (e.g. CodeHolderSystemSettings). Thus, this one line setting declaration would be sufficient if  \textit{caseSensitiveFinds} and \textit{caseSensitiveFinds:} accessors were implemented in \textit{CodeHolderSystemSettings}. Here, instead, these accessors are implemented in \textit{ParagraphEditor}. Then, it must be explicitly set that the target is \textit{ParagraphEditor} as done below:
\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
	<systemsettings>
	(aBuilder setting: #caseSensitiveFinds) 
		target: ParagraphEditor
\end{code}
This very short version is enough to be compiled and taken into account by the settings browser as shown by the screenshot of the \figref{fig:caseSensitiveFinds2}.
\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.4]{caseSensitiveFinds_setting_declaration2}
\caption{the very simple version of the \textit{caseSensitiveFinds} setting}
\figlabel{fig:caseSensitiveFinds2}
\end{center}
\end{figure}
Unfortunately, the presentation is not user-friendly because:
\begin{itemize}
\item the label shown in the settings browser is its identifier,
\item there is no description or explanation available for this setting and,
\item the new setting is simply add at root
\end{itemize}

%Settings are of two main kinds: setting nodes and settings with associated preference~: 
%\begin{itemize}
%\item
%A setting node is used to logically organize  your settings by grouping sub-settings, it represents a node . Such a setting is declared by a method which simply returns a SystemSettingNode instance. Any setting can declare any setting node as its parent.
%\item
%A setting with value is an instance of SettingValue or of one of its subclasses. Such a setting holds a useful global system parameter and is made persistent: it is stored in a class variable which is initialized by the method that declares the setting.
%\end{itemize}

%1 DECLARING A SETTING NODE
%
%All System settings are organized in trees. Each tree root is a setting with no parent (parent set to nil). Whatever setting can be a root. If a root doesn't need to keep any value, then it can be an instance of SystemSettingNode. Such a setting is instanciated with: #SettingManager class>>newNode:. The argument is the name of the node. A setting node is mostly useful for the grouping of several related settings. The dialog instance variable can be set to the name of a dialog class. Then, the SystemSettingBrowser shows a button for this dialog: when pressed, the class which name is the dialog instance variable value receives the #open message. It can be useful in order to open a complex or handy dialog for the input of some settings.
%
%The example below shows a root node named 'System' declared in a SystemSettings class.
%------------------
%SystemSettings class>>systemSettingNode
%	<setting>
%	^ (SettingManager newNode: 'System') description: 'All standard system settings'
%------------------
%
%The example below shows a the declaration of a subnode of systemSettingNode, it is declared in a UISettings class:
%------------------
%UISettings class>>UINode
%	<setting>
%	^ (SettingManager newNode: 'User interface') 
%			description: 'Paramaters for the user interface'; 
%			parent: #systemSettingNode
%------------------
%		
%2 DECLARING SIMPLE VALUE SETTINGS
%
%2.1 PRESENTATION
%A simple value setting is a setting which value is a Boolean, a String, a Symbol, a Number, a Font or a Color. Such a setting is hold by a SettingValue which is instanciated with #SettingManager class>>newSetting:. The argument is the name of the setting.
%If the setting has a default value, then, the setting is declared with the default value as below:
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newSetting: 'My setting name') 
%											description: 'A useful description'; 
%											default: aDefaultValue]
%------------------
%where:
%- MyPackageSettings is a class of MyPackage package (a system setting is declared class side)
%- mySetting is the getter for the setting
%- MySetting is the name of the class variable which value is the setting (instance of SettingValue)
%- 'My setting label' and 'A useful description' are respectively, the name and the description shown by the SystemSettingBrowser.
%- aDefaultValue is the default value for the setting
%
%If the setting doesn't have any default value (or if its default value is nil):
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newSetting: 'My setting name') 
%											description: 'A useful description'; 
%											type: aTypeSymbol]
%------------------
%
%aTypeSymbol is a symbol used by the setting browser in order to know how to build the input widget. By default, possible values are #Boolean, #String, #Symbol, #Integer, #Float, #Font or #Color. It can be of another value but in that case, the class which name is the type value should understand the #settingInputWidgetForNode: message.
%
%Classically, a SettingValue is not a root: it is declared as a child of one or several nodes in order to ease its managing. 
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newSetting: 'My setting name') 
%											description: 'A useful description'; 
%											parent: aParentNodeSelector;
%											type: aTypeSymbol]
%------------------
%
%aParentNodeSelector is a symbol which is the parent node method selector.
%
%A setting node may have several parents:
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newSetting: 'My setting name') 
%											description: 'A useful description'; 
%											parent: firstParentNodeSelector;
%											parent: secondParentNodeSelector;
%											type: aTypeSymbol]
%------------------
%or
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newSetting: 'My setting name') 
%											description: 'A useful description'; 
%											parents: #(firstParentNodeSelector secondParentNodeSelector);
%											type: aTypeSymbol]
%------------------
%
%
%2.2 SIMPLE VALUE SETTING EXAMPLES
%
%2.2.1 Boolean settings
%Definition of the boolean setting "newbyMode" with only a label and a default value:
%------------------
%MyClass class>>newbyMode
%	<setting>
%	^ NewbyMode ifNil: [NewbyMode := (SettingManager newSetting: 'Newby mode') default: false].
%------------------
%						
%A description could be very helpful when using the SystemSettingBrowser: 			
%------------------
%MyClass class>>newbyMode
%	<setting>
%	^ NewbyMode ifNil: [NewbyMode := (SettingManager newSetting: 'Newby mode') 
%			default: false; 
%			description: 'the useful description goes here...'].
%------------------
%
%The default value is optional. If not present, the declaration must explicitly initialize the setting type:
%------------------
%MyClass class>>newbyMode
%	<setting>
%	^ NewbyMode ifNil: [NewbyMode := (SettingManager newSetting: 'Newby mode') 
%			type: #Boolean; 
%			description: 'the useful description goes here...'].
%------------------
%
%2.2.4 Color setting
%Note that the default can be a valuable. Here, the default is given by a MessageSend instance:
%------------------
%MyClass class>>desktopColor
%	<setting>
%	^ DesktopColor
%		ifNil: [DesktopColor := (SettingManager newSetting: 'Desktop color') 
%					parent: #uiColors;
%					description: 'The color used for the desktop background';
%					default: (MessageSend receiver: Color selector: #green)]
%------------------
%
%You can also use a block for the default:
%------------------
%MyClass class>>desktopColor
%	<setting>
%	^ DesktopColor
%		ifNil: [DesktopColor := (SettingManager newSetting: 'Desktop color') 
%					parent: #uiColors;
%					description: 'The color used for the desktop background';
%					default: [Color green]]
%------------------
%
%2.2.5 Font setting
%Here the default is an instance of LogicalFont:
%------------------
%MyClass class>>codeFont
%	<setting>
%	^ CodeFont
%		ifNil: [CodeFont := (SettingManager newSetting: 'Code') description: 'The code font';
%						 parent: #fontSettingNode;
%						 default: (LogicalFont familyName: 'DejaVu Sans' 
%												fallbackFamilyNames: nil 
%												pointSize: 12 
%												stretchValue: 5 
%												weightValue: 400 
%												slantValue: 0)]
%------------------
%
%The default can also be set with a MessageSend instance:
%------------------
%MyClass class>>codeFont
%	<setting>
%	^ CodeFont
%		ifNil: [CodeFont := (SettingManager newSetting: 'Code') description: 'The code font';
%						 parent: #fontSettingNode;
%     				 default: (MessageSend receiver: self selector: #defaultStandardFont)]
%
%MyClass class>>defaultStandardFont
%	^ LogicalFont
%		familyName: 'DejaVu Sans'
%		fallbackFamilyNames: nil
%		pointSize: 12
%		stretchValue: 5
%		weightValue: 400
%		slantValue: 0
%------------------
%
%3 DECLARING A SETTING WITH FINITE SET OF VALUES
%
%3.1 PRESENTATION
%A setting can be defined so that its value is get from a restricted set of values. The setting is an instance of MultipleSettingValue. It is instanciated with #SettingManager class>>newMultiple:. The argument is the name of the setting. The collection of values from which a multiple setting takes its value is always a set of FixedSettingValue. A FixedSettingValue is created with #SettingManager class>>newFixed:.
%
%Such a setting can be of two different kinds :
%- if the valid value list is known at declaration time and is constant, then the list of values is set by sending the #domainValues: message to the setting. The argument is an array of fixed values. 
%
%Such a setting can be declared as below:
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newMultiple: 'My setting name') 
%						description: 'A useful description'; 
%						default: aDefaultValue;
%						domainValues: aListOfFixedSettingValues]
%------------------
%					
%The default should be one of the valid values: a real value which is token from the list of possible values. 
%
%- if the valid value list is not known at declaration time, then the list of possible values is dynamically computed by the SystemSettingBrowser by evaluating the block or the MessageSend stored as the getter instance variable value. The getter instance variable is set by sending the #domainValuesGetter: message to the setting.
%
%Such a setting can be declared as below:
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newMultiple:'My setting name') 
%						description: 'A useful description'; 
%						default: aDefaultValue;
%						domainValuesGetter: aBlockOrAMessageSend]
%------------------
%The argument of #domainValuesGetter: can be a block or a instance of MessageSend. This valuable takes no argument. 
%
%3.2 EXAMPLES 
%
%The declaration gives all possibles values for the setting. Each possible domain value is a fixed setting (read-only setting). Here is the example of #hintingSetting which value can be #Light, #Normal, #Full or #None:
%------------------
%MyClass class>>hintingSetting
%	<setting>
%	^ HintingSetting
%		ifNil: [HintingSetting := (SettingManager newMultiple: 'Hinting')
%						 description: 'Defines the glyph shapes' translated;
%						 parent: #freeTypeSettingNode;
%						 domainValues: {
%							SettingManager newFixed value: #Light. 
%							SettingManager newFixed value: #Normal. 
%							SettingManager newFixed value: #Full. 
%							SettingManager newFixed value: #None
%						}].
%------------------
%
%In the case where domain values are of simple type, as Symbol for example, the shorter declaration given below can be used:		
%------------------
%MyClass class>>hintingSetting
%	<setting>
%	^ HintingSetting
%		ifNil: [HintingSetting := (SettingManager newMultiple: 'Hinting')
%						 description: 'Defines the glyph shapes' translated;
%						 parent: #freeTypeSettingNode;
%						 domainValues: {#Light. #Normal. #Full. #None}]
%------------------
%
%The value domain can also be made of a set of complex objects. The example below shows #themeSetting setting. The value domain is an array with two fixed settings, for UIThemeStandardSqueak and for UIThemeWatery2:
%------------------
%MyClass class>>themeSetting
%	<setting>
%	^ ThemeSetting
%		ifNil: [ThemeSetting := (SettingManager newMultiple: 'UITheme')
%						description: 'The theme to use for UI look and feel';
%						parent: #uiSettingNode;
%						type: #UITheme;
%						default: UIThemeWatery2;
%						domainValues: {
%							(SettingManager newFixed: 'Standard Squeak') value: UIThemeStandardSqueak. 
%							(SettingManager newFixed: 'Watery 2') description: 'Similar to a nice OS'; value: UIThemeWatery2}]
%------------------
%
%The shorter declaration given below can also be used. The domain values is a list of association. Each association key is used as the name of the fixed setting, and the corresponding association value is used as the value of the fixed setting:
%------------------
%MyClass class>>themeSetting
%	<setting>
%	^ ThemeSetting
%		ifNil: [ThemeSetting := (SettingManager newMultiple: 'UI theme')
%						 description: 'The theme to use for UI look and feel';
%						 parent: #uiSettingNode;
%						 type: #UITheme;
%						 default: UIThemeWatery2;
%						 domainValues: {'Standard' -> UIThemeStandardSqueak. 'Watery 2' -> UIThemeWatery2}]
%------------------
%
%Previous version has a serious drawback: the list of possible values is fixed, then the first time the setting is read, the list is definitively built. After its building, there is no way to update the list except by the reinitializing of the corresponding class variable (hard reset). 
%Regarding the themeSetting example, the problem is that new instances of UITheme can be added in the system after the setting has been created and initialized. In order be able to take into account system dependent domain values, you can makes the list dynamically computed. A getter instance variable can be set to a block or to an instance of a MessageSend. Such a valuable is dynamically evaluated by the SystemSettingBrowser in order to get current and up-to-date list of valid values. Here is the themeSetting example revisited:
%
%------------------
%MyClass class>>themeSetting
%	<setting>
%	^ ThemeSetting
%		ifNil: [ThemeSetting := (SettingManager newMultiple:'UI theme')
%						parent: #uiSettingNode;
%						default: UIThemeWatery2;
%						domainValuesGetter: [UITheme allSubclasses collect: [:cls | SettingManager newFixed value: cls]]]
%------------------
%
%or with a much simpler version
%------------------
%MyClass class>>themeSetting
%	<setting>
%	^ ThemeSetting
%		ifNil: [ThemeSetting := (SettingManager newMultiple:'UI theme')
%						parent: #uiSettingNode;
%						default: UIThemeWatery2;
%						domainValuesGetter: [UITheme allSubclasses]]
%------------------
%
%4 DECLARING RANGE SETTING
%
%4.1 PRESENTATION
%A setting for which all possible values are given by a range is an instance of RangeSettingValue. Such a setting is instanciated with #SettingManager class>>newRange:. The argument is the name of the setting. The range is set by sending a #range: message to a setting. The argument is an Interval instance.
%
%Such a setting can be declared as below:
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newRange: 'My setting name') 
%						description: 'A useful description'; 
%						default: aDefaultValue;
%						range: anInterval]
%------------------
%The range is an instance of Interval. It is set by the #range: message and is evaluated by the SystemSettingBrowser when choosing a new value.
%Note that the SystemSettingBrowser presents an input field and a slider. 
%
%4.2 EXAMPLE
%
%------------------
%FontSettings class>>glyphContrast
%	<setting>
%	^ GlyphContrast
%		ifNil: [GlyphContrast := (SettingManager newRange: 'Glyph contrast') 
%						description: 'Change the contrast level for glyphs. This is an integer between 1 and 100';
%						parent: #freeTypeSettingNode;
%						default: 50;
%						range: (1 to: 100)]
%------------------
%
%5 USING SPECIFIC DIALOG
%For setting browsing and editing, it could be useful to use a specific dialog instead of SystemSettingBrowser simple input widgets. For that purpose, the dialog attribute can be set with the name of a dialog class. While browsing a setting with a dialog, the SystemSettingBrowser presents a button for the dialog opening. The only constraint is that the dialog class must understand the #open message.
%
%For a node with children, it can be very useful in order to be able to use a cool dialog for the input of all children instead of being forced to input them one by one as it is the case with the SystemSettingrowser.
%
%Here is an example of a setting node with its dialog instance variable set to the value #FontSettingDialog. In the case of fonts, it could be useful in order to allow the using of a specific cool dialog for font preferences settings.
%------------------
%FontSettings class>>fontSettingNode
%	<setting> 
%	^ (SettingManager newNode: 'Fonts')
%		description: 'System fonts settings';
%		dialog: #FontSettingDialog;
%		parent: #uiSettingNode 
%------------------
%
%The dialog instance variable can be set for a setting value too. Then, neither the default value nor the type is needed:
%------------------
%UISettings class>>uiStyle
%	<setting>
%	^ UIStyle ifNil: [UIStyle := (SettingManager newSetting: 'UI style') 
%			dialog: #UIStyleChooserDialog; 
%			description: 'System style'].
%------------------
%
%6 SIMPLE SETTING WITH CHILDREN
%A setting value can be a parent for another setting value. As an example, #gradientButtonLook can be a child of a boolean setting #advancedGUISetting:
%------------------
%MyClass class>>advancedGUISetting
%	<setting>
%	^ AdvancedGUISetting
%		ifNil: [AdvancedGUISetting := 
%						(SettingManager newSetting: 'Advanced GUI settings')
%						parent: #uiSettingNode;
%						default: true]
%					
%MyClass class>>gradientButtonLook
%	<setting>
%	^ GradientButtonLook
%		ifNil: [GradientButtonLook := 
%						(SettingManager newSetting: 'Gradient look for buttons')
%						parent: #advancedGUISetting;
%						default: true]
%------------------
%


\section{Setting styles management}
\label{sec:SettingStylesManagement}

\section{Extending the setting browser}
\label{sec:ExtendingTheSettingsBrowser}

\section{Programming a preference}
\label{sec:ProgrammingAPreference}

\section{Design of the Settings Framework}
The design of the Settings framework is based on the three following points: (1) a preference is not defined in a global class but local to the package that uses it, (2) settings can be declared independently from the application they refer to, (3) any setting declaration can be loaded even if the Settings framework is not loaded. 

Let's explain now these two points since they have an impact on the modular structure of Pharo. 

\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.3]{Principles}
\caption{The Settings principles}
\figlabel{principles}
\end{center}
\end{figure}

\paragraph{Local value and with a local flow.}

The Settings framework supports the idea that a preference value is local to a package. A package should define either a singleton or a class variable defined somewhere on a class. The methods of the class are able to refer to the variable. The package should provide some way to get and set the value of the preference.

here give an example

Understanding the difference to previous design as implemented in Squeak3.9 or Pharo1.0 is important.
In previous versions, the class Preferences was the place where the preferences were defined as well as methods to change their values. This implies that code using preferences was during its execution referencing the class Preferences.
The flow of control was clearly not local the class using the preferences but always executing some methods on the Preferences class.



@@
here show an example of the old way
@@


\paragraph{Declaration definition.}
While the actual value of a setting should be defined and used locally to a package, the setting declaration (so that the setting value) can be defined externally to the package using class extension or other mecanisms.
In essence a setting declaration is description of a value: it describes how to get its value, how to change it...

This means that you are not forced to define setting declaration in a package that defines a preference value.

@@ here an example@@


\paragraph{No explicit dependency on the Setting Framework.}
Finally when declaring a setting, the code does not refer explicitly to the setting class. This has the good property 
that you can load code containing setting declaration even if the Settings framework is not loaded. This way we make sure 
that we get a modular system. In case the settings framework is not loaded, the method containing the setting declaration 
is just not used by the system.


%\begin{code}{}
%| working |
%working := FSDiskFilesystem current working.
%\end{code} 
%
%Type  the above code into a workspace and evaluate it. It assigns a reference of the current working directory to the variable \ct{working}. References are the central object of the framework and provide the primary mechanism of working with files and directories. They are instances of the class \ct{FSReference}.
%
%Note that you not use platform specific classes such as \ct{FSUnixFilesystem} or \ct{FSWindowsFilesystem}. All code below works on \ct{FSReference} instances.
%
%
%\section{Navigating the Filesystem}
%
%Now let's do some more interesting things. To list children of your working directory evaluate the following expression:
%
%\begin{code}{}
%working := FSDiskFilesystem current working.
%working children.
%\end{code} 
%
%To access all the children of the current directory you can use \ct{allChildren}
%
%\begin{code}{}
%working allChildren.
%\end{code}
%
%
%To get only jpeg files you can for example 
%\begin{code}{}
%working allChildren select: [ :each | each basename endsWith: 'jpeg' ]
%\end{code} 
% 
%To get a reference to a specific file or directory within your working directory use the slash operator:
%
%\begin{code}{}
% cache := working / 'package-cache'.
%\end{code} 
%
%Navigating back to the parent is easy:
%
% cache parent.
%You can check for various properties of the cache directory by evaluating the following expressions:
%\begin{code}{}
% cache exists.             "--> true"
% cache isFile.             "--> false"
% cache isDirectory.        "--> true"
% cache basename.           "--> 'package-cache'"
%\end{code} 
% 
%To get additional information about the filesystem entry evaluate:
%
%\begin{code}{}
% cache entry creation.     "--> 2010-02-14T10:34:31+00:00"
% cache entry modification. "--> 2010-02-14T10:34:31+00:00"
% cache entry size.         "--> 0 (directories have size 0)"
%\end{code} 
%The framework also supports locations, late-bound references that point to a file or directory. When asking to perform a concrete operation, a location behaves the same way as a reference. Currently the following locations are supported:
%
%\begin{code}{}
% FSLocator desktop.
% FSLocator home.
% FSLocator image.
% FSLocator vmBinary.
% FSLocator vmDirectory.
%\end{code} 
%
%If you save a location with your image and move the image to a different machine or operating system, a location will still resolve to the expected directory or file.
%
%\subsection{Opening Read- and Write-Streams}
%
%To open a file-stream on a file ask the reference for a read- or write-stream:
%
%\begin{code}{}
% stream := (working / 'foo.txt') writeStream.
% stream nextPutAll: 'Hello World'.
% stream close.
% stream := (working / 'foo.txt') readStream.
% stream contents.
% stream close.
%\end{code}
%
%Please note that \ct{writeStream} overrides any existing file and \ct{readStream} throws an exception if the file does not exist. There are also short forms available:
%
%\begin{code}{}
% working / 'foo.txt' writeStreamDo: [ :stream | stream nextPutAll: 'Hello World' ].
% working / 'foo.txt' readStreamDo: [ :stream | stream contents ].
%\end{code}
%
%Have a look at the streams protocol of FSReference for other convenience methods.
%
%Renaming, Copying and Deleting Files and Directories
%
%You can also copy and rename files by evaluating:
%
%\begin{code}{}
% (working / 'foo.txt') copyTo: (working / 'bar.txt').
%\end{code} 
%
%To create a directory evaluate:
%\begin{code}{}
% backup := working / 'cache-backup'.
% backup createDirectory.
%\end{code} 
%
%And then to copy the contents of the complete package-cache to that directory simply evaluate:
%
% cache copyAllTo: backup.
%Note, that the target directory would be automatically created, if it was not there before.
%
%To delete a single file evaluate:
%
% (working / 'bar.txt') delete.
%To delete a complete directory tree use the following expression. Be careful with that one though.
%
% backup deleteAll.
% 
%Thats the basic API of the Filesystem library. If there is interest we can have a look at other features and other filesystem types in a next iteration.
%
%
%
% working / 'foo.txt' readStreamDo: [ :stream | stream nextPutAll: 'Hello World' ].
% working / 'foo.txt' writeStreamDo: [ :stream | stream contents ].
%
%
%\section{Design }
%\sd{should add class comments and a uml diagram}
%
%\subsection{Path}
%
%Paths are the most fundamental element of the Filesystem API. They represent filesystem paths in a very abstract sense, and provide a high-level protocol for working with paths without having to manipulate Strings. Here are some examples using the methods that FSPath provides:
%
%\begin{code}{}
%    "absolute path"
%    FSPath / 'plonk' / 'feep'       => /plonk/feep
%    
%    "relative path"
%    FSPath * 'plonk' / 'feep'       => plonk/feep
%
%    "relative path with extension"
%    FSPath * 'griffle' , 'txt'      => griffle.txt
%    
%    "changing the extension"
%    FSPath * 'griffle.txt' , 'jpeg'     => griffle.jpeg
%    
%    "parent directory"
%    (FSPath / 'plonk' / 'griffle') parent   => /plonk
%    
%    "resolving a relative path"
%    (FSPath / 'plonk' / 'griffle') resolve: (FSPath * '..' / 'feep')
%                        => /plonk/feep
%    
%    "resolving an absolute path"
%    (FSPath / 'plonk' / 'griffle') resolve: (FSPath / 'feep')
%                        => /feep
%                        
%    "resolving a string"
%    (FSPath * 'griffle') resolve: 'plonk'   => griffle/plonk
%                        
%    "comparing"
%    (FSPath / 'plonk') contains: (FSPath / 'griffle' / 'nurp')
%                        => false
%\end{code}
%
%\subsection{Filesystem}
%
%A filesystem is an interface to some hierarchy of directories and files. "The filesystem," provided by the host operating system, is embodied by FSDiskFilesystem and it's platform-specific subclasses. But other kinds of Filesystems are also possible. FSMemoryFilesystem provides a RAM diska filesystem where all files are stored as ByteArrays in the image. FSZipFilesystem represents the contents of a zip file.
%
%Each filesystem has its own working directory, which it uses to resolve any relative paths that are passed to it. Some examples:
%
%\begin{code}{}
%    fs := FSMemoryFilesystem new.
%    fs workingDirectory: (FSPath / 'plonk').
%    griffle := FSPath / 'plonk' / 'griffle'.
%    nurp := FSPath * 'nurp'.
%    
%    fs resolve: nurp            => /plonk/nurp
%    
%    fs createDirectory: (FSPath / 'plonk')  => "/plonk created"
%    (fs writeStreamOn: griffle) close.  => "/plonk/griffle created"
%    fs isFile: griffle.         => true
%    fs isDirectory: griffle         => false
%    fs copy: griffle to: nurp       => "/plonk/griffle copied to /plonk/nurp"
%    fs exists: nurp             => true
%    fs delete: griffle          => "/plonk/griffle" deleted
%    fs isFile: griffle          => false
%    fs isDirectory: griffle         => false
%\end{code}
%	
%\subsection{Reference}
%
%Paths and filesystems are the lowest level of the Filesystem API. An FSReference combines a path and a filesystem into a single object which provides a simpler protocol for working with files. It implements the same operations as FSFilesystem , but without the need to track paths and filesystem separately:
%
%
%\begin{code}{}
%    fs := FSMemoryFilesystem new.
%    griffle := fs referenceTo: (FSPath / 'plonk' / 'griffle').
%    nurp := fs referenceTo: (FSPath * 'nurp').
%    
%    griffle isFile              
%    griffle isDirectory 
%    
%    griffle parent ensureDirectory.     
%    griffle writeStreamDo: [:s]         
%    griffle copyTo: nurp            
%    griffle delete              
%\end{code}    
%
%References also implement the path protocol, with methods like \ct{/} , \ct{parent} and \ct{resolve:}.
%
%\subsection{Locator}
%
%Locators could be considered late-bound references. They're left deliberately fuzzy, and only resolved to a concrete reference when some file operation needs to be performed. Instead of a filesystem and path, locators are made up of an origin and a path. An origin is an abstract filesystem location, such as the user's home directory, the image file, or the VM executable. When it receives a message like \ct{isFile}, a locator will first resolve its origin, then resolve its path against the origin.
%
%Locators make it possible to specify things like "an item named 'package-cache' in the same directory as the image file" and have that specification remain valid even if the image is saved and moved to another directory, possibly on a different computer.
%
%\begin{code}{}
%    locator := FSLocator image / 'package-cache'.
%    locator printString             => '{image}/package-cache'
%    locator resolve                 => /Users/colin/Projects/Mason/package-cache
%    locator isFile                  => false
%    locator isDirectory             => true
%\end{code}	
%
%The following origins are currently supported:
%
%\ct{image} - the image file
%\ct{changes} - the changes file
%\ct{vmBinary} - the executable for the running virtual machine
%\ct{vmDirectory} - the directory containing the VM application (may not be the parent of \ct{vmBinary})
%\ct{home} - the user's home directory
%\ct{desktop} - the directory that hold the contents of the user's desktop
%\ct{documents} - the directory where the user's documents are stored
%
%
%Applications my also define their own origins, but the system will not be able to resolve them automatically. Instead, the user will be asked to manually choose a directory. This choice is then cached so that future resolution requests won't require user interaction.
%
%\subsection{Enumeration}
%
%References and Locators also provide simple methods for dealing with whole directory trees:
%
%\begin{description}
%\item[allChildren]
%
%This will answer an array of references to all the files and directories in the directory tree rooted at the receiver. If the receiver is a file, the array will contain a single reference, equal to the receiver.
%
%\item[allEntries]
%This method is similar to \ct{allChildren}, but it answers an array of \ct{FSDirectoryEntries}, rather than references.
%
%\item[copyAllTo: aReference]
%
%This will perform a deep copy of the receiver, to a location specified by the argument. If the receiver is a file, the file will be copied; if a directory, the directory and its contents will be copied recursively. The argument must be a reference that doesn't exist; it will be created by the copy.
%
%\item[deleteAll]
%
%This will perform a recursive delete of the receiver. If the receiver is a file, this has the same effect as \ct{delete}.
%\end{description}
%
%\subsection{Visitors}
%
%The above methods are sufficient for many common tasks, but application developers may find that they need to perform more sophisticated operations on directory trees.
%
%The visitor protocol is very simple. A visitor needs to implement \ct{visitFile:} and \ct{visitDirectory:}. The actual traversal of the filesystem is handled by a guide. A guide works with a visitor, crawling the filesystem and notifying the visitor of the files and directories it discovers. There are three Guide classes, \ct{FSPreorderGuide}, \ct{FSPostorderGuide} and \ct{FSBreadthFirstGuide} , which traverse the filesystem in different orders. To arrange for a guide to traverse the filesystem with a particular visitor is simple. Here's an example:
%
%\begin{code}{}
%    FSBreadthFirstGuide show: aReference to: aVisitor
%\end{code}	
%
%The enumeration methods described above are implemented with visitors; see \ct{FSCopyVisitor}, \ct{FSDeleteVisitor} and \ct{FSCollectVisitor} for examples.



%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: