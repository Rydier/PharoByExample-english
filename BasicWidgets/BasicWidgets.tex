% $Author: ducasse $
% $Date: 2009-08-24 10:17:33 +0200 (Mon, 24 Aug 2009) $
% $Revision: 28563 $

% HISTORY:


%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================

\chapter{Basic Widgets}

\section{The window}
\subsection{Opening a window}
The basic class for managing a window is \ct{StandardWindow}. Let's start with an empty one. To create and open an empty window just try the following:
\begin{code}{}
StandardWindow new openInWorld
\end{code}
You should see a window with a topbar that you can move with the mouse (see FIG~\ref{fig:emptyWindow}). 

\begin{figure}[ht]\centering
	\includegraphics[width=6cm]{EmptyWindow}
	\caption{An empty window}
	\label{fig:emptyWindow}
\end{figure} 

On one side, the topbar has three buttons for closing, collapsing and expanding the window. On the other side, the topbar has a menu button with a default set of items.

\subsection{A window and its model}

To set a model to a window, it's quite easy:

\begin{code}{}
StandardWindow new model: myModel
\end{code}

By specifying a model to a window, and by providing specifics methods, the model will be able to control some of the window's behaviors.

\subsubsection{Example:}

First, let's create the model class

\begin{classdef}{Defining a specific Model.}

Object subclass: #MyModel
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE2-Examples'

MyModel>>#initialExtent

	^ 200@200
\end{classdef}

Let's see the result:

\begin{code}{}
StandardWindow new openInWorld.
StandardWindow new model: (MyModel new); openInWorld.
\end{code}

So you should see a window with the same size than the previous one, and a small window which size is exactly what you have specified in the method \ct{initialExtent} (see FIG~\ref{fig:withAndWithoutModel}).
\sd{should we always specifies a model?}
\ben{If you want to specify the initial extent, either you define a model or you subclass (as far as I know)}
\sd{what should be put in the model vs. the Morph itself?}
\ben{I think/hope it will be clear when the API section will be complete}

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{WithAndWithoutModel}
	\caption{Two windows: one without a model and one with a model}
	\label{fig:withAndWithoutModel}
\end{figure}

You can also defined this method:

\begin{method}{Define if the model is ok to change or not}
okToChange

	^ false
\end{method}

Now, when you try to close the small window nothing happens.

\subsection{Your own topbar menu}

Here, we will show you how to easily add direct and simple shortcuts in the window's menu.

First, your window must have a model, then you simply have to implement the method \mthind{addModelItemsToWindowMenu:}{addModelItemsToWindowMenu: aMenu} and to fill up the menu provided as parameter as following:

\begin{method}{}
addModelItemsToWindowMenu: aMenu
	"Add model-related items to the window menu"
	
	"First, we add a separator"
	aMenu addLine.
	
	"Then, we add our items"
	aMenu
		add: 'Label of the entry'
		target: receiverOfTheFollowingSelector
		action: #selectorWeWantToBeExecuted.

\end{method} 

\subsubsection{Example:}

\begin{method}{Define the extra entries of the menu}
MyModel>>addModelItemsToWindowMenu: aMenu
	"Add model-related items to the window menu"
	super addModelItemsToWindowMenu: aMenu.
	aMenu addLine.
	aMenu
		add: 'Open an inspector on me'
		target: self
		action: #inspect.
\end{method} 

So when you click on the menu button, you see at the end of the list the label we typed just before (see FIG~\ref{fig:menuBar}), and when you click on it, an inspector is opened (see FIG~\ref{fig:windowAndInspector})

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{MenuBar}
	\caption{Menu with our extra item at the end}
	\label{fig:menuBar}
	\includegraphics[width=7cm]{WindowAndInspector}
	\caption{The inspector is well opened}
	\label{fig:windowAndInspector}
\end{figure}

\subsection{Main Window API}

Here is the list of the main API for a window

\begin{itemize}
\item Title
\item Color
\item roundcorners?
\item minimalExtent
\item 

\begin{code}{}
SystemWindow new
	maximumExtent: 200@100; openInWorld

pareil pour 

StandardWindow new
	unexpandedFrame: (0@0 extent: 200@100) ; openInWorld
\end{code}

je ne comprends pas pourquoi je peux alors avoir une fenetre immense?

\item unresizeable?
\item Action on close?
\end{itemize}


\section{Buttons}

\section{Text fields}

\section{Text editor}

\section{Panes and layout managing}

\section{List widgets}

\section{Tree widgets}

\section{Layout or how positioning submorphs}

\ben{Maybe we should write a section about layouts to describe their API ?}
\sd{yes excellent idea. Do you know that luarent and hilaire wrote some text }

Adding a morph to another one is simple using the \ct{addMorph:} message. Now we often want to place a morph at a given place and in particular that the morph occupies space even if its container morph is resized. For that we use layout. Layout are objects that control how to morphs occupy space. Several layouts exist: proportional, 


\subsection{With the default layout into a window}

This section  explains how to add morph into a window with the default layout.

The default layout is ProportionalLayout. To use it, you have to use the method \mthind{addMorph:frame:}{addMorph: aMorph frame: aFrame}
\begin{code}{}
aWindow
	addMorph: morphToAdd
	frame: (x0@y0 corner: x1@y1)
\end{code}
where x0, y0, x1 and y1 are defined as shown in  Figure~\ref{fig:frameExplanation}. Note that their values are floats between 0 and 1.

\begin{figure}[ht]\centering
	\includegraphics[width=6cm]{DefaultFrame}\includegraphics[width=6cm]{FrameExplanation}
	%\caption{How frames are defined}
	%\label{fig:defaultFrame}
	\caption{An example with a frame \ct{0@0 corner: 0.5@0.5}.}
	\label{fig:frameExplanation}
\end{figure}

\subsubsection{Some Morphs}
First, let's define some morphs to illustrate and experiment with.
\begin{code}{Objects definition}
| container redMorph blueMorph greenMorph |
redMorph := Morph new color: Color red; yourself.				
blueMorph := Morph new color: Color blue; yourself.
greenMorph := Morph new  color: Color green; yourself.
container := PanelMorph new.
\end{code}

We will not repeat their definition in the future except in the first code snippet so that you can 
get its full definition. 

\paragraph{A first configuration.}
The following snippet of code asks the red morph to occupy all the space of its container.
\begin{code}{}
| window |
window := SystemWindow new.
redMorph := Morph new color: Color red; yourself.	
window
	addMorph: redMorph
	frame: (0@0 corner: 1@1).
	
redMorph color: Color red.	
window openInWorld
\end{code}
Note: you have to reset the color of the morph after having added it because the window set the default color. Here it seems strange but for more complicated morphs (like buttons, list \dots) it sets the background color for a better integration.

\begin{figure}[ht]\centering
	\includegraphics[width=6cm]{SimpleLayoutExample1}
	\caption{The red morph fill the whole space.}
	\label{fig:simpleLayoutExample1}
\end{figure}

As a result, you can see that the red morph is stretched the fill the space both vertically and horizontally (see Figure~\ref{fig:simpleLayoutExample1}).


\paragraph{A little more complicated configuration.}
Now we add three morphs of different colors. 

\begin{code}{}
window
	addMorph: redMorph
	frame: (0@0 corner: 0.33@1).
window
	addMorph: blueMorph
	frame: (0.33@0 corner: 0.66@1).
window
	addMorph: greenMorph
	frame: (0.66@0 corner: 1@1).
\end{code}

As a result, you can see three stripes of color where each is horizontally a third of the window size and fills the space vertically (see Figure~\ref{fig:simpleLayoutExample2}).

\begin{figure}[ht]\centering
	\includegraphics[width=6cm]{SimpleLayoutExample2}
	\caption{Three color stripes}
	\label{fig:simpleLayoutExample2}
\end{figure}

Note that if you resize the window, proportions are kept. Also note that each stripe can be resized horizontally.

\paragraph{A last example.}
Now we change the configuration of 
\begin{code}{}
window
	addMorph: redMorph
	frame: (0@0 corner: 0.5@0.5).

window
	addMorph: blueMorph
	frame: (0.5@0 corner: 1@0.5).

window
	addMorph: greenMorph
	frame: (0@0.5 corner: 1@1).
\end{code}

As you may guess, the result is composed by two squares above a green rectangle (see Figure~\ref{fig:simpleLayoutExample3}).

\begin{figure}[ht]\centering
	\includegraphics[width=6cm]{SimpleLayoutExample3}
	\caption{Two squares above and a rectangle below}
	\label{fig:simpleLayoutExample3}
\end{figure}

Note that like for the previous example, you can resize each part. So basically, you now know everything about the default layout.


%----------------------------------------------------------------------------------------------
%
%				More Complicated Layouts
%
%----------------------------------------------------------------------------------------------


\subsection{More complicated layouts}

This section explains how to use different layouts and to use them to add morphs into another morph, which is a window or not.

Now that we have seen the default layout, we introduce you quickly the other layouts:
\begin{itemize}
	\item LayoutFrame
	\item RowLayout
	\item StackLayout
	\item TableLayout
\end{itemize}

\subsubsection{LayoutFrame}

This layout is used when you have to specified both a fix part \footnote{independent of the size of the window} and a proportional part\footnote{like the ProportionalLayout}.

This layout is used by example to add a toolbar.

To use this layout, you will have to use the method \mthind{addMorph:fullFrame:}{addMorph: aMorph fullFrame: aLayout} as follows:

\begin{code}{}
toolBarHeight := 100.
window
	addMorph: redMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 1@0) "proportional part"
				offsets: (0@0 corner: 0@toolBarHeight)). "fix part"
window
	addMorph: blueMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 1@1) "proportional part"
				offsets: (0@toolBarHeight corner: 0@0)). "fix part"
\end{code}

\sd{can you explain fractions: (0@0 corner: 1@1)?}


As a result, you can see the red static part and the blue part which fill the space. When you resize the window, the red part will always stay the same (see Figure~\ref{fig:layoutFrame}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{LayoutFrame}
	\caption{Fix red part and dynamic blue part}
	\label{fig:layoutFrame}
\end{figure}

Here is another example showing the fixed sized bar at the bottom of the window.
\begin{code}{}
toolBarHeight := 100.
window
	addMorph: redMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 1@1) "proportional part"
				offsets: (0@0 corner: 0@(toolBarHeight negated))). "fix part"
window
	addMorph: blueMorph
	fullFrame: (LayoutFrame
				fractions: (0@1 corner: 1@1) "proportional part"
				offsets: (0@(toolBarHeight negated) corner: 0@0)). "fix part"
\end{code}

Here you can see that the fix part (the blue one) is below (see Figure~\ref{fig:layoutFrame2}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{LayoutFrame2}
	\caption{Fix blue part and red blue part}
	\label{fig:layoutFrame2}
\end{figure}

Let's try a bit more complicated example:
\begin{code}{}
toolBarHeight := 100.
window
	addMorph: redMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 1@0.4) "proportional part"
				offsets: (0@0 corner: 0@0)). "fix part"
window
	addMorph: greenMorph
	fullFrame: (LayoutFrame
				fractions: (0@0.4 corner: 1@0.4)
				offsets: (0@0 corner: 0@toolBarHeight)).				
window
	addMorph: blueMorph
	fullFrame: (LayoutFrame
				fractions: (0@0.4 corner: 1@1) "proportional part"
				offsets: (0@toolBarHeight corner: 0@0)). "fix part"
window openInWorld.
\end{code}

So now, the fix part is the green morph which stick in the middle of the window (see Figure~\ref{fig:layoutFrame3}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{LayoutFrame3}
	\caption{Dynamic red and blue parts and green fix part}
	\label{fig:layoutFrame3}
\end{figure}

\begin{figure}[!ht]\centering
	\includegraphics[width=6cm]{LayoutFrame4}
	\caption{Dynamic red and blue parts and green fix part}
	\label{fig:layoutFrame4}
\end{figure}

Of course, you can do the same vertically:
\begin{code}{}
toolBarWidth := 50.
window
	addMorph: redMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 0.4@1) "proportional part"
				offsets: (0@0 corner: 0@0)). "fix part"				
window
	addMorph: greenMorph
	fullFrame: (LayoutFrame
				fractions: (0.4@0 corner: 0.4@1)
				offsets: (0@0 corner: toolBarWidth@0)).				
window
	addMorph: blueMorph
	fullFrame: (LayoutFrame
				fractions: (0.4@0 corner: 1@1) "proportional part"
				offsets: (toolBarWidth@0 corner: 0@0)). "fix part"
\end{code}

So the result is the same but vertically (see Figure~\ref{fig:layoutFrame4}).



\subsection{RowLayout}
The row layout is used to add submorphs in a single row where each submorph will be equally dispatched.

So let's try to use it. The message \ct{layoutPolicy:} specifies the new layout.
\begin{code}{}
window layoutPolicy: RowLayout new.

window 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.

window openInWorld.
\end{code}

As you can see, the window title bar is misplaced because it is added by the system using the same method once the layout has been changed (see Figure~\ref{fig:rowLayout1}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{RowLayout1}
	\caption{The title bar is misplaced}
	\label{fig:rowLayout1}
\end{figure}

To fix that, we will use a container instance of \ct{PanelMorph}.
\begin{code}{}
container := PanelMorph new.
container layoutPolicy: RowLayout new.
container 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.
window
	addMorph: container
	frame: (0@0 corner: 1@1).
window openInWorld.
\end{code}

As you can see, it's a bit better, but the morphs do not fill the whole space (see FIG~\ref{fig:rowLayout2}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{RowLayout2}
	\caption{The title bar is well placed, but morphs do not fill the whole space}
	\label{fig:rowLayout2}
\end{figure}

So let's fix that using \ct{hResizing:} and \ct{vResizing:}. 

\begin{code}{}
container := PanelMorph new.
container layoutPolicy: RowLayout new.
redMorph
	hResizing: #spaceFill;
	vResizing: #spaceFill.
blueMorph
	hResizing: #spaceFill;
	vResizing: #spaceFill.
greenMorph
	hResizing: #spaceFill;
	vResizing: #spaceFill.
container 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.
window
	addMorph: container
	frame: (0@0 corner: 1@1).
window openInWorld.
\end{code}

So for each submorph we have specified that both vertically and horizontally it should fill the space.
The result is what we have expected (see Figure~\ref{fig:rowLayout3}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{RowLayout3}
	\caption{Finally what we expected}
	\label{fig:rowLayout3}
\end{figure}

Note that contrary to the ProportionalLayout, here you can't resize any part.

\subsection{StackLayout}

\ben{I do not know how it works ... Should ask Igor}
\sd{or  may be we should drop it. Ask igor}

\subsection{TableLayout}
This layout is used to align submorphs following a row or a column and taking in account a direction.
So by default, the layout builds a column directed from top to bottom.
\begin{code}{}
container := PanelMorph new.
container 
	layoutPolicy: TableLayout new;
	listDirection: #topToBottom.
{ redMorph. blueMorph. greenMorph } do: [:each |
	each 
		hResizing: #spaceFill;
		vResizing: #spaceFill ].
container 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.
window
	addMorph: container
	frame: (0@0 corner: 1@1).
window openInWorld.
\end{code}

So we obtain a column where any morph is dispatched equally (see Figure~\ref{fig:tableLayout1}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{TableLayout1}
	\caption{TableLayout by default}
	\label{fig:tableLayout1}
\end{figure}

Note that you can't resize any submorph and that you have add in order:
red, blue and green and you get 
green, blue and  red.

The explanation is that when you add a morph following the direction, it's done like in Tetris, you make them fall following the direction. But the direction is kept when there is space to keep.


The following example show a situation  where we do not force each morph to expand vertically
\begin{code}{}
container := PanelMorph new.
container 
	layoutPolicy: TableLayout new;
	listDirection: #topToBottom.
{ redMorph. blueMorph. greenMorph } do: [:each |
	each hResizing: #spaceFill ].
container 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.
window
	addMorph: container
	frame: (0@0 corner: 1@1).
window openInWorld.
\end{code}

Here you see that the space is kept below submorphs (see Figure~\ref{fig:tableLayout2}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{TableLayout2}
	\caption{The space is left below submorphs}
	\label{fig:tableLayout2}
\end{figure}

You can also experiment the other directions

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{TableLayout3}
	\caption{Bottom To Top}
	\label{fig:tableLayout3}
	\includegraphics[width=7cm]{TableLayout4}
	\caption{Left To Righ}
	\label{fig:tableLayout4}
	\includegraphics[width=7cm]{TableLayout5}
	\caption{Right To Left}
	\label{fig:tableLayout5}
\end{figure}


\section{Conclusion}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: